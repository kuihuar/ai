### 水平触发VS边缘触发

它们的大概区别决定了操作系统何时通知应用程序IO事件就绪

#### 水平触发（level-triggered, lt）

##### 核心逻辑
- 通知条件：只要文件描述符fd的IO状态满足可读或可写条件，就会持续触发通知
- 类比： 类似持续提醒，比如当快递放门口时，系统会一直提醒你有快递，直到取走

##### 工作流程
1. 假设fd对应的内核缓冲区有数据可读
2. 调用epoll_wait后，应用程序收到通知，开始读取事件
3. 如果应用程序未一次性读完所有数据，剩余数据仍留在内核缓冲区。
4. 下次调用epoll_wait时，会再次通知该fd可读。直到数据被读完。

##### 特点
- 编程简单： 无需担心数据未读完导致丢失
- 可能多次通知：若未及时处理数据，会重复触发事件
- 默认模式： select，poll和epll的默认触发方式
- LT模式下，即使只读取了一次，未读完的数据会再次触发事件

##### 示例场景

```c
char buf[1024]
while (true) {
    int n = read(fd, buf, sizeof(buf));
    if (n <= 0) break;
}
```

#### 边缘触发（edge-triggered, lt）

##### 核心逻辑
- 通知条件：仅当fd的IO状态发生变化时（如不可读变为可读），触发一次通知
- 类比： 相当于单次提醒，快递员放下快递时，提醒一次，不会再提醒

##### 工作流程
1. 假设fd对应的内核缓冲区从空变为有数据
2. 调用epoll_wait后，应用程序收到一次通知
3. 应用程序必须一次性读完所有数据，否则剩余的数据不会再触发事件
4. 只有当新数据到达时（状态再次发生变化）， 才会触发新的事件

##### 特点

- 高效： 减少重复通知，适合高并发
- 编程复杂： 必须循环读到数据直到EAGAIN
- 需非阻塞IO：fd必须设置非阻塞式，避免read/write阻塞线程
- ET 模式下，必须读到直到EAGAIN, 否则会丢失数据

##### 示例
```c
char buf[1024];
while (true) {
    int n = read(fd, buf, sizeof(buf));
    if (n >0) {
        //handle data
    } else if (n == 0){
        break;// close
    } else if (errno == EAGAIN || errno == EWOULDBOLCK) {
        break; // handle complete
    } else {
        // handle error
        break;
    }
}
```

#### 对比表格

| 特性 | 水平触发（LT） | 边缘触发（ET） |
| ---- | ---- | ---- |
| 通知条件 | 只要状态满足就通知（如缓冲区有数据） | 仅状态变化时通知（如缓冲区从空变为非空） |
| 触发次数 | 可能多次触发（直到数据被处理完） | 仅触发一次（除非有新数据到达） |
| 数据未读完的后果 | 下次 epoll_wait() 会再次通知 | 剩余数据不会触发新事件，可能丢失 |
| 性能 | 可能因重复通知导致效率略低 | 更高效，减少无效通知 |
| 编程复杂度 | 简单（允许单次读取） | 复杂（必须循环读取到 EAGAIN） |
| 适用场景 | 通用场景，编程简单 | 高并发场景，需极致性能优化 |


#### 实际场景分析
##### 场景 1：LT 模式的重复通知

- 假设内核缓冲区有 2KB 数据，应用程序每次读取 1KB。

- LT 模式：

    1. 第一次 epoll_wait() 通知可读，读取 1KB，剩余 1KB。

    2. 第二次 epoll_wait() 仍会通知可读，直到剩余 1KB 被读取。

- ET 模式：

    1. 仅第一次 epoll_wait() 通知可读，必须一次性读取 2KB，否则剩余 1KB 不会触发新事件。

##### 场景 2：ET 模式的高效性
- 若 10 个客户端同时发送数据，LT 模式可能触发 10 次通知，而 ET 模式可能合并为 1 次通知（通过 epoll_wait() 返回多个就绪的 fd）。

#### 总结

- LT模式：像持续提醒的闹钟，适合简单的场景，但可能产生冗余事件
- ET模式：像单次触发的开关，需要精准处理，但性能更优
- 核心区别在于事件通知的触发条件和数据处理的完整性要求