### 定义
IO操作是指程序与外部设备（磁盘OR网络）的数据交换。

### 理解

- 阻塞IO： 当程序调用一个IO函数时，比如读取文件或者接收网络数据，程序会一直等待，直到数据准备好并用操作完成，这时候进程会被阻塞，不能做其它事情。
- 非阻塞IO： 当调用IO函数后，不管有没有数据都立即返回，不会让进程阻塞，如果没有数据就返回一个错误。这样程序可以做其它事情。然后不断轮询检查是否有数据。但这样效率不高，需不断查询状态，消耗CPU资源。
- IO多路复用： 用过一个机制同时监控多个IO描述符，当其中任务一个就绪时，就通知程序进行处理。这样程序可以同时处理多个IO，而不用为每个IO单独创建线程程。如果没有就绪的IO，进程会被阻塞，直到有就绪的，所以属于同步的范畴，真正的IO操作还是需要程序自己去调用。
- 异步IO： 程序发起一个IO操作后，立即返回，不需要等待操作完成。操作系统会在后台处理IO。

---

### 再理解

- 阻塞IO： 两个阶段都阻塞
- 非阻塞IO： 第一个阶段不阻塞（立即返回），但是需要轮询，第二个阶段可能阻塞
- IO多路复用： 第一个阶段由select处理，阻塞，当有就绪时，第二个阶段可能阻塞
- 异步IO：两个阶段都不阻塞，由内核完成，完成的通知


---

### 五个例子    

- 阻塞IO： 一直等待数据准备好，然后复制到用户空间，返回
- 非阻塞IO： 软询检查数据是否准备好，准备好后复制数据，返回
- IO多路利用： 使用select等函数监控多个描述述，当有就绪时再处理
- 信号驱动IO： 当数据准备好时，内华达州发送SIGIO信号通知进程，进程再处理
- 异步IO： 内核完成所有操作，包括数据复制后，通知进程

---

### 区别

1. 阻塞IO（Blocking IO）
    - 特点：调用IO操作时，进程会被阻塞，直到数据完全就绪并完成拷贝。

    - 流程：

        1. 用户线程发起系统调用（如recv()）。

        2. 内核等待数据就绪（如网络数据到达内核缓冲区）。

        3. 用户线程被阻塞，直到数据就绪且拷贝到用户空间。

    - 典型场景：传统Socket编程的默认模式。

    - 关键词：全程阻塞、同步。

2. 非阻塞IO（Non-blocking IO）
    - 特点：调用IO操作时，若数据未就绪，立即返回错误（如EWOULDBLOCK），用户线程需轮询重试。

    - 流程：

        1. 用户线程发起非阻塞系统调用（如recv()）。

        2. 若数据未就绪，内核直接返回错误码。

        3 用户线程轮询检查数据是否就绪，直到成功读取。

    - 优点：避免线程长时间阻塞，可执行其他任务。

    - 缺点：频繁轮询消耗CPU资源。

    - 关键词：轮询检查、同步非阻塞。

3. IO多路复用（IO Multiplexing）
    - 特点：通过select/poll/epoll等系统调用监控多个文件描述符，当任一描述符就绪时通知用户线程。

    - 流程：

        1. 用户线程调用select()阻塞等待多个文件描述符。

        2. 当某个描述符就绪，select()返回。

        3. 用户线程再发起系统调用（如recv()）读取数据。

    - 优点：单线程处理多IO，避免多线程开销。

    - 缺点：实际数据读写仍可能阻塞。

    - 典型场景：高并发服务器（如Nginx、Redis）。

    - 关键词：多路监控、同步阻塞（select()阶段）。

4. 异步IO（Asynchronous IO，AIO）
    - 特点：用户线程发起IO请求后立即返回，内核完成所有操作（包括数据拷贝）后主动通知用户线程。

    - 流程：

        1. 用户线程调用aio_read()发起异步请求。

        2. 内核立即返回，用户线程继续执行。

        3. 内核完成数据就绪和拷贝后，通过信号或回调通知用户线程。

    - 优点：完全非阻塞，用户线程无需参与任何等待。

    - 缺点：实现复杂，依赖操作系统支持（如Linux的io_uring）。

    - 典型场景：高性能异步框架（如Node.js、Libuv）。

    - 关键词：全程非阻塞、异步。

---

### 对比

| 模型 | 同步/异步 | 阻塞/非阻塞 | 典型系统调用 | 用户线程参与度 |
| ---- |---------| ---------- | ---------- | ----------- |
| 阻塞IO |同步 | 阻塞 | read()/recv() | 全程阻塞等待|
| 非阻塞IO | 同步 | 非阻塞 | read()+轮询 | 需轮询检查状态 |
| IO多路复用 | 同步 | 阻塞（select阶段） | select()/epoll() | 阻塞在监控调用，再处理就绪IO |
| 异步IO | 异步 | 非阻塞 | aio_read() | 完全不参与IO过程 |

---

### 总结

- 阻塞IO： 简单但效率低，适合低并发场景
- 非阻塞IO： 需轮询，CPU开销大，实际较少直接使用
- IO多路复用： 高并发核心模型，通过单线程管理多IO
- 异步IO： 性能最优，但实现复杂，依赖操作系统支持

---

### 核心划分与标准
1. 同步VS异步
    - 同步IO： 用户线程需主动等待或轮询IO结果（如阻塞IO， 非阻塞IO， IO多路复用）
    - 异步IO： 内核完成所有操作的主动通过用户纯种，用户线程无需待
2. 阻塞VS非阻塞
    - 阻塞： 调用后线程无法执行其它任务，直到操作过完成
    - 非阻塞： 调用后立即返回，线程可继续执行其它任务  


