- 首先数组和切片，数组是固定长度的，而切片是动态的，可以动态扩展。不过具体细节可能还需要再确认一下。比如数组的长度是类型的一部分，而切片不是。这意味着两个不同长度的数组是不能互相赋值的，类型不同.
- 内存分配方面，数组是在栈上还是堆上分配？可能要看具体情况，但一般来说数组是值类型，而切片是引用类型，底层引用一个数组。切片的结构包括指针、长度和容量
- 声明方式的不同，用户可能想知道如何区分声明数组和切片。比如var a [3]int 是数组，而var b []int 是切片，或者用make创建切片。初始化的时候，数组需要指定长度，而切片可以用字面量或者make函数
- 传递方式方面，数组作为参数传递时会被复制，而切片传递的是引用，所以修改切片会影响底层数组。这部分可能需要用例子说明，比如函数内修改数组不影响原数组，但修改切片会影响
- 动态扩容的机制，切片在append时如果超过容量，会重新分配一个更大的数组，通常是双倍扩容，然后将旧数据复制过去。这时候新切片和旧切片的底层数组就不同了
- 使用场景的话，数组适合固定长度的数据，比如配置项，而切片适合需要动态变化的情况，比如处理不确定数量的数据
- 可能用户还会混淆切片的默认值，比如声明一个切片但未初始化时是nil，而数组声明后就有零值。这点也要提到，避免使用时出现错误
- 切片的截取操作，比如s := arr[1:3]，这时候s的指针指向arr的第二个元素，长度是2，容量则是从1到原数组末尾的长度
- 切片的三个属性：指针、长度、容量,  make([]T, len, cap) 创建切片，len是长度，cap是容量，默认情况下len=cap
- 数组作为函数参数时，会复制整个数组，修改不影响原数组, 
- 切片作为函数参数时，传递的是引用，修改元素会影响底层数组
- 数组能直接比较，切片不能直接比较，只能通过for循环逐个元素比较或者与nil比较

```go
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:3]  // s = [2, 3]，长度 2，容量 4（从索引 1 到末尾）

var s []int //：未初始化的切片，值为 nil。

s := []int{} //：初始化了的空切片，值不为 nil。
// 切片在 append 时，若容量不足，会触发扩容
```

1. 扩容触发条件
当切片的**长度（len）超过容量（cap）**时，调用 append 会触发扩容：
2. 扩容策略（Go 1.18 及之后）
Go 1.18 优化了扩容策略，规则更复杂，核心逻辑如下：

(1) 预估新容量
基本规则：新容量（newCap）至少为 旧容量（oldCap） + 新增元素个数（num)。

动态增长因子：

如果 oldCap < 256，直接翻倍（newCap = 2 * oldCap）。

如果 oldCap ≥ 256，按公式计算：
newCap = oldCap + (oldCap + 3*256) / 4
（即逐步降低增长比例，避免内存浪费）。

(2) 内存对齐优化
根据切片元素类型的大小（et.size），调整 newCap 使其满足内存对齐要求。

例如：[]int64 每个元素占 8 字节，newCap 会被调整为 8 的倍数。

(3) 最终容量确定
最终 newCap 取上述计算值和预估值的较大者，确保容量足够。

3. 旧版本策略（Go 1.17 及之前）
旧规则：

若 oldCap < 1024，新容量翻倍（newCap = 2 * oldCap）。

若 oldCap ≥ 1024，每次增加 25%（newCap = oldCap * 1.25）。

Go 1.18 后弃用此规则，改为更平滑的增长策略。
