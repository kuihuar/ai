### goroutine与thread的区别，为什么轻量？
> **区别有以下几点**:
1. 实现层级不同：
    - goroutine 由 go 运行时管理，属于用户态线程
    - thread 由操作系统管理，属于内核态线程
2. 调度机制：
    - goroutine 由 go 运行时调度，采用 M:N 模型，协作为主，异步抢占，上下文切换在用户态。
    - thread 由操作系统调度，采用1:1模型，抢占式，上下文切换在内核态。
3. 资源消耗
    - goroutine 的栈很小，只有2KB，可扩展到1G，百成个Goroutine没有问题。
    - thread 的栈一般是1MB-2MB,大量线程可能耗尽内存, 1000个线程就是1G内存
4. 创建与开销
    - goroutine 创建与销毁微秒级，完全由go 运行时管理，无系统调用。
    - thread 创建与销毁有系统调用，由操作系统管理，通常要毫秒级时间，频繁捉拿性能损耗显著，创建线程开销大。        
4. 并发模型：
    - goroutine 基于CSP模型，通过channel进行通信，共享数据，无锁，无阻塞。
    - thead 通常基于共享内存模型和同步原语（互斥锁、信号量），通过锁，信号量待同步机制。
5. 错误隔离：
    - goroutine 单个goroutine panic 不会影响其他goroutine，可恢复。
    - thread 线程崩溃可能导致进程终止，无法恢复。
6. 并行性与多核利用
    - goroutine 通过GOMAXPROCS设置最大并发数，支持多核并行执行，由调度器分配任务。
    - thread 直接绑定内核线程，可充分利用多核，但线程数据过多时，内核调度将成为瓶颈。
7. 开发复杂度：
    - goroutine 语法简单，易于使用，无需手动管理同步。
    - thread 语法复杂，需要手动管理锁，信号量，避免死锁。
8. 适用场景：
    - goroutine 适用于高并发，轻量级任务，如网络编程，I/O密集型应用。
    - thread 适用于需要大量线程的场景，如CPU密集型计算，需要大量线程的场景。
9. 总结：
    - goroutine 轻量，高效，适合高并发场景。
    - thread 重量级，适合需要大量线程的场景，如CPU密集型计算。    

 


> **简单对比表**

|维度|	Goroutine|	线程（Thread）|
|---|---|---|
|实现层级|	用户态|	内核态|
|内存开销|	2KB（可扩展）|	1~8MB（固定）|
|调度开销|	极低（用户态调度）|	较高（涉及内核切换）|
|创建数量|	轻松支持百万级|	通常数百到数千
|并发模型|	Channel 通信（CSP）|	共享内存 + 锁
|错误隔离|	单 Goroutine panic 可恢复|	线程崩溃可能导致进程终止|
|开发复杂度|	低（语法糖支持）|	高（需手动管理同步）    |
> **为什么轻量？**
1. 极低的内存开销
2. 用户态调度，无需内核态切换
3. 高效的创建与销毁
4. 协作式与抢占式调度
5. 天然的高并发支持
> **总结：轻量的本质**
轻量并非单一特性，而是通过用户态调度，动态栈内存，高效调度策略和资源复用等机制共同实现系统级优化。将并发单元的资源消耗和调度成本降至最低。使开发者可以使用线程一样简单的操作Goroutine.

> **内存占用详细比较**
> 动态栈机制，避免固定大小的的栈内存浪费
> 高效堆内存管理，分层分配加GC, 减少内存碎片

|维度|	Goroutine|	线程（Thread）| remark|
|---|---|---| 
|栈内存|	2KB（可扩展,当前线大小的2倍，最大为1G）|	1~8MB（固定）|ulimit -s 查看|
|堆内存|	动态分配（可扩展， 基于TCmalloc 回垃圾回收，效率高）|	静态分配（固定）||


