### 责任链模式应用于中间件的场景
[]: # 1. 日志记录
[]: # 2. 权限校验
[]: # 3. 限流
[]: # 4. 缓存


|模式|含义|作用|场景|
|--|--|--|--|
|*责任链模式|将请求的处理过程封装成一条链，每个处理器决定是否处理请求，或将请求传递给下一个处理器|解耦请求发送者和处理器，增加处理器灵活性|当请求需要多个对象处理，且处理顺序不确定时|
|*简单工厂模式和工厂方法模式|定义一个创建对象的接口，但由子类决定实例化哪个类，简单工厂模式是创建一个类的实例，工厂方法模式是创建一个类的实例|解耦对象创建和使用，支持灵活扩展|当需要创建多个相关对象，且创建过程复杂，且需要支持灵活扩展时|
|*策略模式|对像有某个行为，但在不同的场景中，该行为有不同的实现算法，策略模式可以定义一系列算法，将每个算法封装起来，并使它们可以相互替换，策略模式可以定义一系列算法，将每个算法封装起来，并使它们可以相互替换，策略模式可以定义一系列算法，将每个算法封装起来，并使它们可以相互替换|支持灵活扩展，支持算法替换|当需要实现多种算法，且需要支持灵活扩展时|
|*依赖反转原则|高层模块不应该依赖低层模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象|解耦模块之间的依赖关系，支持灵活扩展|当需要实现模块之间的解耦，且需要支持灵活扩展时|
|*建造者模式和函数选项模式|将复杂对象的创建过程封装成一个独立的类，通过链式调用设置对象的属性，最后构建对象|创建复杂对象，支持灵活配置对象属性|当对象的创建过程复杂，且需要支持多种配置方式时|
|工厂方法模式和抽象工厂模式|定义一个创建对象的接口，但由子类决定实例化哪个类，工厂方法模式是创建一个类的实例，抽象工厂模式是创建一组相关或相互依赖的对象|解耦对象创建和使用，支持灵活扩展|当需要创建多个相关对象，且创建过程复杂，且需要支持多种配置方式时|
|单例模式和享元模式|保证一个类只有一个实例，并提供一个全局访问点，享元模式则是共享对象，减少内存占用|保证对象唯一性，减少内存占用|当需要确保一个类只有一个实例，且需要提供全局访问点时|
|观察者模式和发布-订阅模式|定义对象之间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并自动更新|解耦对象之间的依赖关系，支持灵活扩展|当需要实现对象之间的一对多依赖关系，且需要支持灵活扩展时|
|*策略模式和状态模式|定义一系列算法，将每个算法封装起来，并使它们可以相互替换，状态模式则是定义一个对象的状态，并在状态之间进行切换|支持灵活扩展，支持状态转换|当需要实现多种算法，且需要支持灵活扩展时|
|接口隔离原则|客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上|支持灵活扩展，支持接口隔离|当需要实现接口隔离，且需要支持灵活扩展时|
|里氏替换原则|子类对象应该能够替换掉所有父类对象，且程序的行为不会发生变化|支持灵活扩展，支持多态性|当需要实现子类对象替换父类对象，且需要支持灵活扩展时|
|单一职责原则|一个类应该只有一个引起它变化的原因|支持灵活扩展，支持代码复用|当需要实现单一职责，且需要支持灵活扩展时|
|迪米特法则|一个对象应该对其他对象保持最少的了解，降低耦合性|支持灵活扩展，支持代码复用|当需要实现低耦合，且需要支持灵活扩展时|
|开闭原则|软件实体（类、模块、函数等）应该对扩展开放，对修改关闭|支持灵活扩展，支持代码复用|当需要实现软件实体的扩展，且需要支持灵活扩展时|
|装饰器模式|动态地给对象添加额外的职责，装饰器模式是一种结构型设计模式，它允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为|增加对象功能，支持灵活扩展|当需要动态地给对象添加额外的职责，且需要支持灵活扩展时|
|代理模式|提供一个代理对象，控制对原始对象的访问，代理模式是一种结构型设计模式，它允许你提供一个代理对象，控制对原始对象的访问，代理模式是一种结构型设计模式，它允许你提供一个代理对象，控制对原始对象的访问|控制对象访问，支持灵活扩展|当需要控制对原始对象的访问，且需要支持灵活扩展时|
|迭代器模式|提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部表示|支持遍历聚合对象，支持灵活扩展|当需要遍历聚合对象，且需要支持灵活扩展时|
|适配器模式|将一个类的接口转换成客户希望的另一个接口，适配器模式是一种结构型设计模式，它允许你将一个类的接口转换成客户希望的另一个接口|支持不同接口的兼容，支持灵活扩展|当需要支持不同接口的兼容，且需要支持灵活扩展时|
|桥接模式|将抽象部分与它的实现部分分离，使它们都可以独立地变化|支持不同实现的组合，支持灵活扩展|当需要支持不同实现的组合，且需要支持灵活扩展时|
|组合模式|将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式是一种结构型设计模式，它允许你将对象组合成树形结构以表示“部分-整体”的层次结构|支持层次结构的组合，支持灵活扩展|当需要支持层次结构的组合，且需要支持灵活扩展时|
|外观模式|为子系统中的一组接口提供一个一致的界面，外观模式是一种结构型设计模式，它为子系统中的一组接口提供一个一致的界面，从而降低了子系统的复杂度，使得子系统更易于使用|简化接口，支持灵活扩展|当需要简化接口，且需要支持灵活扩展时|
|享元模式|共享对象，减少内存占用，享元模式是一种结构型设计模式，它通过共享对象来减少内存占用，从而提高系统的性能，享元模式是一种结构型设计模式，它通过共享对象来减少内存占用，从而提高系统的性能|减少内存占用，支持灵活扩展|当需要减少内存占用，且需要支持灵活扩展时|