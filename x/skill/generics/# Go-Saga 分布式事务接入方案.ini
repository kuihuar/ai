# Go-Saga åˆ†å¸ƒå¼äº‹åŠ¡æ¥å…¥æ–¹æ¡ˆ

## ğŸ“‹ é¡¹ç›®èƒŒæ™¯åˆ†æ

### å½“å‰ä¸šåŠ¡åœºæ™¯
nancalacc æ˜¯ä¸€ä¸ªä¼ä¸šçº§è´¦æˆ·åŒæ­¥ç³»ç»Ÿï¼Œä¸»è¦ä¸šåŠ¡æµç¨‹åŒ…æ‹¬ï¼š
- **é’‰é’‰ç»„ç»‡æ¶æ„æ•°æ®åŒæ­¥**ï¼ˆå…¨é‡/å¢é‡ï¼‰
- **WPS ç³»ç»Ÿé›†æˆ**
- **ç”¨æˆ·å’Œéƒ¨é—¨å…³ç³»ç®¡ç†**
- **ä»»åŠ¡çŠ¶æ€è·Ÿè¸ªå’Œç¼“å­˜**

### ç°æœ‰é—®é¢˜
1. **æ•°æ®ä¸€è‡´æ€§é—®é¢˜**ï¼šå¤šæ­¥éª¤æ“ä½œç¼ºä¹äº‹åŠ¡ä¿è¯
2. **é”™è¯¯å¤„ç†å¤æ‚**ï¼šéƒ¨åˆ†å¤±è´¥æ—¶éš¾ä»¥å›æ»š
3. **å¹¶å‘æ§åˆ¶ä¸è¶³**ï¼šç¼ºä¹åˆ†å¸ƒå¼äº‹åŠ¡åè°ƒ
4. **ç›‘æ§å›°éš¾**ï¼šæ— æ³•è·Ÿè¸ªåˆ†å¸ƒå¼æ“ä½œçš„æ‰§è¡ŒçŠ¶æ€

## ğŸ¯ Saga æ¨¡å¼é€‚ç”¨æ€§åˆ†æ

### é€‚åˆ Saga çš„ä¸šåŠ¡åœºæ™¯
1. **å…¨é‡åŒæ­¥æµç¨‹**ï¼šæ¶‰åŠå¤šä¸ªå¾®æœåŠ¡å’Œæ•°æ®åº“æ“ä½œ
2. **å¢é‡åŒæ­¥æµç¨‹**ï¼šéœ€è¦ä¿è¯æ•°æ®ä¸€è‡´æ€§
3. **ç¬¬ä¸‰æ–¹ç³»ç»Ÿé›†æˆ**ï¼šé’‰é’‰ API + WPS API è°ƒç”¨
4. **æ‰¹é‡æ•°æ®å¤„ç†**ï¼šç”¨æˆ·ã€éƒ¨é—¨ã€å…³ç³»æ•°æ®çš„å¹¶å‘å¤„ç†

### æ ¸å¿ƒä¼˜åŠ¿
- **æœ€ç»ˆä¸€è‡´æ€§**ï¼šé€šè¿‡è¡¥å¿æ“ä½œä¿è¯æ•°æ®ä¸€è‡´æ€§
- **æ€§èƒ½ä¼˜åŒ–**ï¼šé¿å…é•¿æ—¶é—´é”å®šèµ„æº
- **å®¹é”™èƒ½åŠ›**ï¼šæ”¯æŒéƒ¨åˆ†å¤±è´¥å’Œè‡ªåŠ¨æ¢å¤
- **å¯è§‚æµ‹æ€§**ï¼šå®Œæ•´çš„æ‰§è¡Œè½¨è¿¹å’ŒçŠ¶æ€è·Ÿè¸ª

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### 1. Saga åè°ƒå™¨æ¶æ„

```go
// Saga åè°ƒå™¨æ¥å£
type SagaCoordinator interface {
    // å¯åŠ¨ Saga äº‹åŠ¡
    StartSaga(ctx context.Context, sagaID string, steps []SagaStep) error
    
    // æ‰§è¡Œ Saga æ­¥éª¤
    ExecuteStep(ctx context.Context, sagaID string, stepID string) error
    
    // è¡¥å¿æ“ä½œ
    CompensateStep(ctx context.Context, sagaID string, stepID string) error
    
    // æŸ¥è¯¢ Saga çŠ¶æ€
    GetSagaStatus(ctx context.Context, sagaID string) (*SagaStatus, error)
}

// Saga æ­¥éª¤å®šä¹‰
type SagaStep struct {
    ID          string                 `json:"id"`
    Name        string                 `json:"name"`
    Action      func(ctx context.Context) error `json:"-"`
    Compensate  func(ctx context.Context) error `json:"-"`
    RetryPolicy *RetryPolicy           `json:"retry_policy"`
    Timeout     time.Duration          `json:"timeout"`
    DependsOn   []string               `json:"depends_on"`
    Metadata    map[string]interface{} `json:"metadata"`
}

// Saga çŠ¶æ€
type SagaStatus struct {
    SagaID      string                 `json:"saga_id"`
    Status      SagaStatusType         `json:"status"`
    CurrentStep string                 `json:"current_step"`
    Progress    int                    `json:"progress"`
    StartTime   time.Time              `json:"start_time"`
    EndTime     *time.Time             `json:"end_time,omitempty"`
    Steps       map[string]StepStatus  `json:"steps"`
    Error       *SagaError             `json:"error,omitempty"`
}
```

### 2. æ•°æ®æ¨¡å‹è®¾è®¡

```sql
-- Saga äº‹åŠ¡è¡¨
CREATE TABLE saga_transactions (
    id VARCHAR(64) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    status ENUM('pending', 'in_progress', 'completed', 'failed', 'compensating') NOT NULL,
    current_step VARCHAR(64),
    progress INT DEFAULT 0,
    start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    end_time TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_status (status),
    INDEX idx_start_time (start_time)
);

-- Saga æ­¥éª¤è¡¨
CREATE TABLE saga_steps (
    id VARCHAR(64) PRIMARY KEY,
    saga_id VARCHAR(64) NOT NULL,
    step_name VARCHAR(255) NOT NULL,
    status ENUM('pending', 'in_progress', 'completed', 'failed', 'compensated') NOT NULL,
    action_data JSON,
    compensate_data JSON,
    error_message TEXT,
    retry_count INT DEFAULT 0,
    max_retries INT DEFAULT 3,
    start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    end_time TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (saga_id) REFERENCES saga_transactions(id) ON DELETE CASCADE,
    INDEX idx_saga_id (saga_id),
    INDEX idx_status (status)
);

-- Saga äº‹ä»¶æ—¥å¿—è¡¨
CREATE TABLE saga_events (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    saga_id VARCHAR(64) NOT NULL,
    step_id VARCHAR(64),
    event_type ENUM('saga_started', 'step_started', 'step_completed', 'step_failed', 'compensation_started', 'compensation_completed', 'saga_completed', 'saga_failed') NOT NULL,
    event_data JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_saga_id (saga_id),
    INDEX idx_created_at (created_at)
);
```

## ğŸš€ å®ç°æ–¹æ¡ˆ

### 1. æ ¸å¿ƒ Saga åè°ƒå™¨å®ç°

```go
// internal/saga/coordinator.go
package saga

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    "github.com/go-kratos/kratos/v2/log"
    "github.com/google/uuid"
)

type Coordinator struct {
    repo   Repository
    logger log.Logger
    mu     sync.RWMutex
}

func NewCoordinator(repo Repository, logger log.Logger) *Coordinator {
    return &Coordinator{
        repo:   repo,
        logger: logger,
    }
}

// StartSaga å¯åŠ¨ä¸€ä¸ªæ–°çš„ Saga äº‹åŠ¡
func (c *Coordinator) StartSaga(ctx context.Context, name string, steps []SagaStep) (string, error) {
    sagaID := uuid.New().String()
    
    // åˆ›å»º Saga äº‹åŠ¡è®°å½•
    saga := &SagaTransaction{
        ID:        sagaID,
        Name:      name,
        Status:    SagaStatusPending,
        StartTime: time.Now(),
        Steps:     make(map[string]*SagaStepRecord),
    }
    
    // åˆå§‹åŒ–æ­¥éª¤è®°å½•
    for _, step := range steps {
        saga.Steps[step.ID] = &SagaStepRecord{
            ID:         step.ID,
            SagaID:     sagaID,
            StepName:   step.Name,
            Status:     StepStatusPending,
            RetryCount: 0,
            MaxRetries: step.RetryPolicy.MaxRetries,
            StartTime:  time.Now(),
        }
    }
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    if err := c.repo.CreateSaga(ctx, saga); err != nil {
        return "", fmt.Errorf("failed to create saga: %w", err)
    }
    
    // è®°å½•äº‹ä»¶
    c.repo.LogEvent(ctx, sagaID, "", EventTypeSagaStarted, nil)
    
    // å¼‚æ­¥æ‰§è¡Œç¬¬ä¸€ä¸ªæ­¥éª¤
    go c.executeSaga(context.Background(), sagaID)
    
    c.logger.Log(log.LevelInfo, "msg", "saga started", "saga_id", sagaID, "name", name)
    return sagaID, nil
}

// executeSaga æ‰§è¡Œ Saga äº‹åŠ¡
func (c *Coordinator) executeSaga(ctx context.Context, sagaID string) {
    defer func() {
        if r := recover(); r != nil {
            c.logger.Log(log.LevelError, "msg", "saga execution panicked", "saga_id", sagaID, "panic", r)
            c.handleSagaFailure(ctx, sagaID, fmt.Errorf("saga execution panicked: %v", r))
        }
    }()
    
    // è·å– Saga ä¿¡æ¯
    saga, err := c.repo.GetSaga(ctx, sagaID)
    if err != nil {
        c.logger.Log(log.LevelError, "msg", "failed to get saga", "saga_id", sagaID, "err", err)
        return
    }
    
    // æ›´æ–°çŠ¶æ€ä¸ºæ‰§è¡Œä¸­
    if err := c.repo.UpdateSagaStatus(ctx, sagaID, SagaStatusInProgress); err != nil {
        c.logger.Log(log.LevelError, "msg", "failed to update saga status", "saga_id", sagaID, "err", err)
        return
    }
    
    // æŒ‰ä¾èµ–é¡ºåºæ‰§è¡Œæ­¥éª¤
    for _, step := range saga.Steps {
        if err := c.executeStep(ctx, sagaID, step.ID); err != nil {
            c.logger.Log(log.LevelError, "msg", "step execution failed", "saga_id", sagaID, "step_id", step.ID, "err", err)
            c.handleSagaFailure(ctx, sagaID, err)
            return
        }
    }
    
    // æ‰€æœ‰æ­¥éª¤æ‰§è¡ŒæˆåŠŸï¼Œå®Œæˆ Saga
    if err := c.repo.UpdateSagaStatus(ctx, sagaID, SagaStatusCompleted); err != nil {
        c.logger.Log(log.LevelError, "msg", "failed to complete saga", "saga_id", sagaID, "err", err)
        return
    }
    
    c.repo.LogEvent(ctx, sagaID, "", EventTypeSagaCompleted, nil)
    c.logger.Log(log.LevelInfo, "msg", "saga completed successfully", "saga_id", sagaID)
}

// executeStep æ‰§è¡Œå•ä¸ªæ­¥éª¤
func (c *Coordinator) executeStep(ctx context.Context, sagaID, stepID string) error {
    step, err := c.repo.GetStep(ctx, sagaID, stepID)
    if err != nil {
        return fmt.Errorf("failed to get step: %w", err)
    }
    
    // æ›´æ–°æ­¥éª¤çŠ¶æ€ä¸ºæ‰§è¡Œä¸­
    if err := c.repo.UpdateStepStatus(ctx, sagaID, stepID, StepStatusInProgress); err != nil {
        return fmt.Errorf("failed to update step status: %w", err)
    }
    
    c.repo.LogEvent(ctx, sagaID, stepID, EventTypeStepStarted, nil)
    
    // æ‰§è¡Œæ­¥éª¤æ“ä½œ
    var stepErr error
    for attempt := 0; attempt <= step.MaxRetries; attempt++ {
        if attempt > 0 {
            c.logger.Log(log.LevelInfo, "msg", "retrying step", "saga_id", sagaID, "step_id", stepID, "attempt", attempt)
            time.Sleep(time.Duration(attempt) * time.Second) // ç®€å•çš„é€€é¿ç­–ç•¥
        }
        
        stepErr = c.executeStepAction(ctx, sagaID, stepID)
        if stepErr == nil {
            break
        }
        
        // æ›´æ–°é‡è¯•æ¬¡æ•°
        c.repo.UpdateStepRetryCount(ctx, sagaID, stepID, attempt+1)
    }
    
    if stepErr != nil {
        // æ­¥éª¤æ‰§è¡Œå¤±è´¥
        c.repo.UpdateStepStatus(ctx, sagaID, stepID, StepStatusFailed)
        c.repo.UpdateStepError(ctx, sagaID, stepID, stepErr.Error())
        c.repo.LogEvent(ctx, sagaID, stepID, EventTypeStepFailed, map[string]interface{}{
            "error": stepErr.Error(),
        })
        return stepErr
    }
    
    // æ­¥éª¤æ‰§è¡ŒæˆåŠŸ
    c.repo.UpdateStepStatus(ctx, sagaID, stepID, StepStatusCompleted)
    c.repo.LogEvent(ctx, sagaID, stepID, EventTypeStepCompleted, nil)
    
    return nil
}

// handleSagaFailure å¤„ç† Saga å¤±è´¥
func (c *Coordinator) handleSagaFailure(ctx context.Context, sagaID string, err error) {
    c.logger.Log(log.LevelError, "msg", "saga failed, starting compensation", "saga_id", sagaID, "err", err)
    
    // æ›´æ–° Saga çŠ¶æ€ä¸ºå¤±è´¥
    c.repo.UpdateSagaStatus(ctx, sagaID, SagaStatusFailed)
    c.repo.LogEvent(ctx, sagaID, "", EventTypeSagaFailed, map[string]interface{}{
        "error": err.Error(),
    })
    
    // æ‰§è¡Œè¡¥å¿æ“ä½œ
    go c.compensateSaga(context.Background(), sagaID)
}

// compensateSaga æ‰§è¡Œè¡¥å¿æ“ä½œ
func (c *Coordinator) compensateSaga(ctx context.Context, sagaID string) {
    saga, err := c.repo.GetSaga(ctx, sagaID)
    if err != nil {
        c.logger.Log(log.LevelError, "msg", "failed to get saga for compensation", "saga_id", sagaID, "err", err)
        return
    }
    
    // æ›´æ–°çŠ¶æ€ä¸ºè¡¥å¿ä¸­
    c.repo.UpdateSagaStatus(ctx, sagaID, SagaStatusCompensating)
    
    // æŒ‰ç›¸åé¡ºåºæ‰§è¡Œè¡¥å¿æ“ä½œ
    for _, step := range saga.Steps {
        if step.Status == StepStatusCompleted {
            if err := c.compensateStep(ctx, sagaID, step.ID); err != nil {
                c.logger.Log(log.LevelError, "msg", "compensation failed", "saga_id", sagaID, "step_id", step.ID, "err", err)
                // è¡¥å¿å¤±è´¥ä¹Ÿéœ€è¦è®°å½•ï¼Œä½†ä¸ä¸­æ–­å…¶ä»–è¡¥å¿æ“ä½œ
            }
        }
    }
    
    c.logger.Log(log.LevelInfo, "msg", "saga compensation completed", "saga_id", sagaID)
}
```

### 2. ä¸šåŠ¡é›†æˆå±‚

```go
// internal/biz/saga_sync.go
package biz

import (
    "context"
    "fmt"
    "time"
    
    "nancalacc/internal/saga"
    v1 "nancalacc/api/account/v1"
)

// SagaSyncUsecase é›†æˆ Saga çš„åŒæ­¥ç”¨ä¾‹
type SagaSyncUsecase struct {
    coordinator *saga.Coordinator
    repo        *accounterRepo
    appAuth     *dingtalk.AppAuth
    wps         *wps.WpsClient
    bizConf     *conf.BizConf
    logger      log.Logger
}

// CreateSyncAccountWithSaga ä½¿ç”¨ Saga æ¨¡å¼åˆ›å»ºåŒæ­¥è´¦æˆ·
func (uc *SagaSyncUsecase) CreateSyncAccountWithSaga(ctx context.Context, req *v1.CreateSyncAccountRequest) (*v1.CreateSyncAccountReply, error) {
    taskId := req.GetTaskName()
    if taskId == "" {
        return nil, status.Error(codes.InvalidArgument, "task name is empty")
    }
    
    // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å·²å­˜åœ¨
    _, ok, err := uc.GetCacheTask(ctx, taskId)
    if err != nil {
        return nil, err
    }
    if ok {
        return nil, status.Error(codes.AlreadyExists, "task name "+taskId+" exists")
    }
    
    // å®šä¹‰ Saga æ­¥éª¤
    steps := []saga.SagaStep{
        {
            ID:     "validate_task",
            Name:   "éªŒè¯ä»»åŠ¡",
            Action: uc.validateTaskAction(taskId),
        },
        {
            ID:     "fetch_dingtalk_data",
            Name:   "è·å–é’‰é’‰æ•°æ®",
            Action: uc.fetchDingTalkDataAction(),
            RetryPolicy: &saga.RetryPolicy{
                MaxRetries: 3,
                Backoff:    time.Second * 5,
            },
        },
        {
            ID:     "save_company_config",
            Name:   "ä¿å­˜å…¬å¸é…ç½®",
            Action: uc.saveCompanyConfigAction(),
        },
        {
            ID:     "save_departments",
            Name:   "ä¿å­˜éƒ¨é—¨æ•°æ®",
            Action: uc.saveDepartmentsAction(),
            RetryPolicy: &saga.RetryPolicy{
                MaxRetries: 2,
                Backoff:    time.Second * 3,
            },
        },
        {
            ID:     "save_users",
            Name:   "ä¿å­˜ç”¨æˆ·æ•°æ®",
            Action: uc.saveUsersAction(),
            RetryPolicy: &saga.RetryPolicy{
                MaxRetries: 2,
                Backoff:    time.Second * 3,
            },
        },
        {
            ID:     "save_relations",
            Name:   "ä¿å­˜ç”¨æˆ·éƒ¨é—¨å…³ç³»",
            Action: uc.saveRelationsAction(),
            RetryPolicy: &saga.RetryPolicy{
                MaxRetries: 2,
                Backoff:    time.Second * 3,
            },
        },
        {
            ID:     "notify_wps",
            Name:   "é€šçŸ¥ WPS ç³»ç»Ÿ",
            Action: uc.notifyWPSAction(),
            RetryPolicy: &saga.RetryPolicy{
                MaxRetries: 3,
                Backoff:    time.Second * 10,
            },
        },
        {
            ID:     "update_task_status",
            Name:   "æ›´æ–°ä»»åŠ¡çŠ¶æ€",
            Action: uc.updateTaskStatusAction(taskId),
        },
    }
    
    // å¯åŠ¨ Saga äº‹åŠ¡
    sagaID, err := uc.coordinator.StartSaga(ctx, "sync_account_"+taskId, steps)
    if err != nil {
        return nil, fmt.Errorf("failed to start saga: %w", err)
    }
    
    uc.logger.Log(log.LevelInfo, "msg", "saga started for sync account", "saga_id", sagaID, "task_id", taskId)
    
    return &v1.CreateSyncAccountReply{
        TaskId:     taskId,
        SagaId:     sagaID,
        CreateTime: timestamppb.Now(),
    }, nil
}

// å®šä¹‰å„ä¸ªæ­¥éª¤çš„ Action å‡½æ•°
func (uc *SagaSyncUsecase) validateTaskAction(taskId string) func(ctx context.Context) error {
    return func(ctx context.Context) error {
        return uc.CreateCacheTask(ctx, taskId, "pending")
    }
}

func (uc *SagaSyncUsecase) fetchDingTalkDataAction() func(ctx context.Context) error {
    return func(ctx context.Context) error {
        // è·å–é’‰é’‰ access_token
        accessToken, err := uc.appAuth.GetAccessToken(ctx)
        if err != nil {
            return fmt.Errorf("failed to get access token: %w", err)
        }
        
        // è·å–éƒ¨é—¨å’Œç”¨æˆ·æ•°æ®
        // ... å®ç°æ•°æ®è·å–é€»è¾‘
        
        return nil
    }
}

func (uc *SagaSyncUsecase) saveCompanyConfigAction() func(ctx context.Context) error {
    return func(ctx context.Context) error {
        // ä¿å­˜å…¬å¸é…ç½®
        // ... å®ç°ä¿å­˜é€»è¾‘
        return nil
    }
}

func (uc *SagaSyncUsecase) saveDepartmentsAction() func(ctx context.Context) error {
    return func(ctx context.Context) error {
        // ä¿å­˜éƒ¨é—¨æ•°æ®
        // ... å®ç°ä¿å­˜é€»è¾‘
        return nil
    }
}

func (uc *SagaSyncUsecase) saveUsersAction() func(ctx context.Context) error {
    return func(ctx context.Context) error {
        // ä¿å­˜ç”¨æˆ·æ•°æ®
        // ... å®ç°ä¿å­˜é€»è¾‘
        return nil
    }
}

func (uc *SagaSyncUsecase) saveRelationsAction() func(ctx context.Context) error {
    return func(ctx context.Context) error {
        // ä¿å­˜ç”¨æˆ·éƒ¨é—¨å…³ç³»
        // ... å®ç°ä¿å­˜é€»è¾‘
        return nil
    }
}

func (uc *SagaSyncUsecase) notifyWPSAction() func(ctx context.Context) error {
    return func(ctx context.Context) error {
        // é€šçŸ¥ WPS ç³»ç»Ÿ
        // ... å®ç°é€šçŸ¥é€»è¾‘
        return nil
    }
}

func (uc *SagaSyncUsecase) updateTaskStatusAction(taskId string) func(ctx context.Context) error {
    return func(ctx context.Context) error {
        return uc.UpdateCacheTask(ctx, taskId, "completed", 100)
    }
}
```

### 3. æ•°æ®è®¿é—®å±‚

```go
// internal/data/saga_repository.go
package data

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    
    "nancalacc/internal/saga"
    "github.com/go-kratos/kratos/v2/log"
    "gorm.io/gorm"
)

type sagaRepository struct {
    data *Data
    log  log.Logger
}

func NewSagaRepository(data *Data, logger log.Logger) saga.Repository {
    return &sagaRepository{
        data: data,
        log:  logger,
    }
}

// CreateSaga åˆ›å»º Saga äº‹åŠ¡
func (r *sagaRepository) CreateSaga(ctx context.Context, saga *saga.SagaTransaction) error {
    db, err := r.data.GetMainDB()
    if err != nil {
        return err
    }
    
    // åˆ›å»ºäº‹åŠ¡è®°å½•
    tx := &models.SagaTransaction{
        ID:          saga.ID,
        Name:        saga.Name,
        Status:      string(saga.Status),
        CurrentStep: saga.CurrentStep,
        Progress:    saga.Progress,
        StartTime:   saga.StartTime,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }
    
    if err := db.WithContext(ctx).Create(tx).Error; err != nil {
        return fmt.Errorf("failed to create saga transaction: %w", err)
    }
    
    // åˆ›å»ºæ­¥éª¤è®°å½•
    for _, step := range saga.Steps {
        stepRecord := &models.SagaStep{
            ID:         step.ID,
            SagaID:     saga.ID,
            StepName:   step.StepName,
            Status:     string(step.Status),
            RetryCount: step.RetryCount,
            MaxRetries: step.MaxRetries,
            StartTime:  step.StartTime,
            CreatedAt:  time.Now(),
            UpdatedAt:  time.Now(),
        }
        
        if err := db.WithContext(ctx).Create(stepRecord).Error; err != nil {
            return fmt.Errorf("failed to create saga step: %w", err)
        }
    }
    
    return nil
}

// GetSaga è·å– Saga äº‹åŠ¡
func (r *sagaRepository) GetSaga(ctx context.Context, sagaID string) (*saga.SagaTransaction, error) {
    db, err := r.data.GetMainDB()
    if err != nil {
        return nil, err
    }
    
    var tx models.SagaTransaction
    if err := db.WithContext(ctx).Where("id = ?", sagaID).First(&tx).Error; err != nil {
        return nil, fmt.Errorf("failed to get saga transaction: %w", err)
    }
    
    // è·å–æ­¥éª¤è®°å½•
    var steps []models.SagaStep
    if err := db.WithContext(ctx).Where("saga_id = ?", sagaID).Find(&steps).Error; err != nil {
        return nil, fmt.Errorf("failed to get saga steps: %w", err)
    }
    
    saga := &saga.SagaTransaction{
        ID:          tx.ID,
        Name:        tx.Name,
        Status:      saga.SagaStatusType(tx.Status),
        CurrentStep: tx.CurrentStep,
        Progress:    tx.Progress,
        StartTime:   tx.StartTime,
        EndTime:     tx.EndTime,
        Steps:       make(map[string]*saga.SagaStepRecord),
    }
    
    for _, step := range steps {
        saga.Steps[step.ID] = &saga.SagaStepRecord{
            ID:         step.ID,
            SagaID:     step.SagaID,
            StepName:   step.StepName,
            Status:     saga.StepStatusType(step.Status),
            RetryCount: step.RetryCount,
            MaxRetries: step.MaxRetries,
            StartTime:  step.StartTime,
            EndTime:    step.EndTime,
        }
    }
    
    return saga, nil
}

// UpdateSagaStatus æ›´æ–° Saga çŠ¶æ€
func (r *sagaRepository) UpdateSagaStatus(ctx context.Context, sagaID string, status saga.SagaStatusType) error {
    db, err := r.data.GetMainDB()
    if err != nil {
        return err
    }
    
    updates := map[string]interface{}{
        "status":     string(status),
        "updated_at": time.Now(),
    }
    
    if status == saga.SagaStatusCompleted || status == saga.SagaStatusFailed {
        updates["end_time"] = time.Now()
    }
    
    if err := db.WithContext(ctx).Model(&models.SagaTransaction{}).
        Where("id = ?", sagaID).
        Updates(updates).Error; err != nil {
        return fmt.Errorf("failed to update saga status: %w", err)
    }
    
    return nil
}

// LogEvent è®°å½•äº‹ä»¶
func (r *sagaRepository) LogEvent(ctx context.Context, sagaID, stepID, eventType string, eventData map[string]interface{}) error {
    db, err := r.data.GetMainDB()
    if err != nil {
        return err
    }
    
    dataJSON, _ := json.Marshal(eventData)
    
    event := &models.SagaEvent{
        SagaID:    sagaID,
        StepID:    stepID,
        EventType: eventType,
        EventData: string(dataJSON),
        CreatedAt: time.Now(),
    }
    
    if err := db.WithContext(ctx).Create(event).Error; err != nil {
        return fmt.Errorf("failed to log event: %w", err)
    }
    
    return nil
}
```

### 4. æœåŠ¡å±‚é›†æˆ

```go
// internal/service/account_saga.go
package service

import (
    "context"
    
    v1 "nancalacc/api/account/v1"
    "nancalacc/internal/biz"
    "github.com/go-kratos/kratos/v2/log"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
)

// CreateSyncAccountWithSaga ä½¿ç”¨ Saga æ¨¡å¼çš„åŒæ­¥è´¦æˆ·åˆ›å»º
func (s *AccountService) CreateSyncAccountWithSaga(ctx context.Context, req *v1.CreateSyncAccountRequest) (*v1.CreateSyncAccountReply, error) {
    s.log.Log(log.LevelInfo, "msg", "CreateSyncAccountWithSaga", "req", req)
    
    // å‚æ•°éªŒè¯
    if req.GetTaskName() != "" && len(req.GetTaskName()) != 14 {
        return nil, status.Errorf(codes.InvalidArgument, "invalid taskname: %s", req.GetTaskName())
    }
    
    if req.GetTaskName() == "" {
        taskId := time.Now().Add(time.Duration(1) * time.Second).Format("20060102150405")
        req.TaskName = &taskId
    }
    
    // é™æµæ£€æŸ¥
    if !s.limiter.Allow("global_sync_account", 10, 20) {
        return nil, status.Errorf(codes.ResourceExhausted, "global rate limit exceeded")
    }
    
    if req.GetTaskName() != "" {
        if !s.limiter.Allow("task_"+req.GetTaskName(), 2, 5) {
            return nil, status.Errorf(codes.ResourceExhausted, "task rate limit exceeded for: %s", req.GetTaskName())
        }
    }
    
    // è°ƒç”¨ä¸šåŠ¡å±‚
    return s.sagaSyncUsecase.CreateSyncAccountWithSaga(ctx, req)
}

// GetSagaStatus è·å– Saga çŠ¶æ€
func (s *AccountService) GetSagaStatus(ctx context.Context, req *v1.GetSagaStatusRequest) (*v1.GetSagaStatusReply, error) {
    s.log.Log(log.LevelInfo, "msg", "GetSagaStatus", "req", req)
    
    if req.SagaId == "" {
        return nil, status.Errorf(codes.InvalidArgument, "saga_id is empty")
    }
    
    status, err := s.sagaSyncUsecase.GetSagaStatus(ctx, req.SagaId)
    if err != nil {
        return nil, err
    }
    
    return &v1.GetSagaStatusReply{
        SagaId:      status.SagaID,
        Status:      string(status.Status),
        CurrentStep: status.CurrentStep,
        Progress:    int32(status.Progress),
        StartTime:   timestamppb.New(status.StartTime),
        EndTime:     timestamppb.New(status.EndTime),
        Error:       status.Error,
    }, nil
}
```

## ğŸ”§ é…ç½®å’Œä¾èµ–ç®¡ç†

### 1. ä¾èµ–æ³¨å…¥é…ç½®

```go
// cmd/server/wire.go
//go:build wireinject
// +build wireinject

package main

import (
    "nancalacc/internal/biz"
    "nancalacc/internal/conf"
    "nancalacc/internal/data"
    "nancalacc/internal/server"
    "nancalacc/internal/service"
    "nancalacc/internal/saga"
    
    "github.com/go-kratos/kratos/v2"
    "github.com/go-kratos/kratos/v2/log"
    "github.com/google/wire"
)

func wireApp(*conf.Server, *conf.Data, log.Logger) (*kratos.App, func(), error) {
    panic(wire.Build(
        server.ProviderSet,
        data.ProviderSet,
        biz.ProviderSet,
        service.ProviderSet,
        saga.ProviderSet,
        newApp,
    ))
}
```

### 2. æ•°æ®åº“è¿ç§»

```sql
-- migrations/001_create_saga_tables.sql
-- åˆ›å»º Saga ç›¸å…³è¡¨ç»“æ„
-- (ä¸Šè¿° SQL è¯­å¥)
```

### 3. é…ç½®æ–‡ä»¶

```yaml
# configs/config.yaml
saga:
  # Saga åè°ƒå™¨é…ç½®
  coordinator:
    # æœ€å¤§å¹¶å‘ Saga æ•°é‡
    max_concurrent_sagas: 10
    # æ­¥éª¤æ‰§è¡Œè¶…æ—¶æ—¶é—´
    step_timeout: 30m
    # è¡¥å¿æ“ä½œè¶…æ—¶æ—¶é—´
    compensation_timeout: 10m
    # é‡è¯•ç­–ç•¥
    retry:
      max_attempts: 3
      backoff_multiplier: 2
      initial_delay: 1s
      max_delay: 30s
  
  # å­˜å‚¨é…ç½®
  storage:
    # äº‹ä»¶ä¿ç•™æ—¶é—´
    event_retention_days: 30
    # æ¸…ç†é—´éš”
    cleanup_interval: 1h
    # æ‰¹é‡æ¸…ç†å¤§å°
    batch_size: 1000
```

## ğŸ“Š ç›‘æ§å’Œå¯è§‚æµ‹æ€§

### 1. æŒ‡æ ‡æ”¶é›†

```go
// internal/saga/metrics.go
package saga

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    sagaTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "saga_total",
            Help: "Total number of saga transactions",
        },
        []string{"status"},
    )
    
    sagaDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "saga_duration_seconds",
            Help:    "Duration of saga transactions",
            Buckets: prometheus.DefBuckets,
        },
        []string{"name"},
    )
    
    stepTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "saga_step_total",
            Help: "Total number of saga steps",
        },
        []string{"status", "step_name"},
    )
    
    compensationTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "saga_compensation_total",
            Help: "Total number of compensation operations",
        },
        []string{"status"},
    )
)
```

### 2. æ—¥å¿—è®°å½•

```go
// ç»“æ„åŒ–æ—¥å¿—è®°å½•
func (c *Coordinator) logSagaEvent(sagaID, stepID, eventType string, details map[string]interface{}) {
    c.logger.Log(
        log.LevelInfo,
        "msg", "saga event",
        "saga_id", sagaID,
        "step_id", stepID,
        "event_type", eventType,
        "details", details,
        "timestamp", time.Now(),
    )
}
```

### 3. å¥åº·æ£€æŸ¥

```go
// internal/saga/health.go
package saga

import (
    "context"
    "time"
)

type HealthChecker struct {
    coordinator *Coordinator
}

func (h *HealthChecker) Check(ctx context.Context) error {
    // æ£€æŸ¥æ•°æ®åº“è¿æ¥
    // æ£€æŸ¥åè°ƒå™¨çŠ¶æ€
    // æ£€æŸ¥æ´»è·ƒ Saga æ•°é‡
    return nil
}
```

## ğŸš€ éƒ¨ç½²å’Œè¿ç»´

### 1. Docker é…ç½®

```dockerfile
# Dockerfile
FROM golang:1.23-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN go build -o main ./cmd/server

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/

COPY --from=builder /app/main .
COPY --from=builder /app/configs ./configs

EXPOSE 8000
EXPOSE 9000

CMD ["./main"]
```

### 2. Kubernetes éƒ¨ç½²

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nancalacc-saga
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nancalacc-saga
  template:
    metadata:
      labels:
        app: nancalacc-saga
    spec:
      containers:
      - name: nancalacc
        image: nancalacc:latest
        ports:
        - containerPort: 8000
        - containerPort: 9000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secret
              key: url
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5
```

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. å¹¶å‘æ§åˆ¶
- é™åˆ¶åŒæ—¶æ‰§è¡Œçš„ Saga æ•°é‡
- ä½¿ç”¨è¿æ¥æ± ç®¡ç†æ•°æ®åº“è¿æ¥
- å®ç°æ­¥éª¤çº§åˆ«çš„å¹¶å‘æ‰§è¡Œ

### 2. ç¼“å­˜ç­–ç•¥
- ç¼“å­˜é¢‘ç¹è®¿é—®çš„ Saga çŠ¶æ€
- ä½¿ç”¨ Redis å­˜å‚¨äº‹ä»¶æ—¥å¿—
- å®ç°åˆ†å¸ƒå¼é”é¿å…é‡å¤æ‰§è¡Œ

### 3. æ‰¹é‡å¤„ç†
- æ‰¹é‡æ’å…¥äº‹ä»¶æ—¥å¿—
- æ‰¹é‡æ›´æ–° Saga çŠ¶æ€
- å¼‚æ­¥æ¸…ç†è¿‡æœŸæ•°æ®

## ğŸ”’ å®‰å…¨è€ƒè™‘

### 1. è®¿é—®æ§åˆ¶
- å®ç°åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶
- éªŒè¯ Saga æ“ä½œæƒé™
- è®°å½•æ“ä½œå®¡è®¡æ—¥å¿—

### 2. æ•°æ®ä¿æŠ¤
- åŠ å¯†æ•æ„Ÿæ•°æ®
- å®ç°æ•°æ®è„±æ•
- å®šæœŸå¤‡ä»½ Saga çŠ¶æ€

## ğŸ“‹ å®æ–½è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€æ¡†æ¶ (1-2å‘¨)
1. å®ç°æ ¸å¿ƒ Saga åè°ƒå™¨
2. åˆ›å»ºæ•°æ®åº“è¡¨ç»“æ„
3. å®ç°åŸºæœ¬çš„ CRUD æ“ä½œ

### ç¬¬äºŒé˜¶æ®µï¼šä¸šåŠ¡é›†æˆ (2-3å‘¨)
1. é›†æˆç°æœ‰åŒæ­¥ä¸šåŠ¡
2. å®ç°è¡¥å¿æ“ä½œ
3. æ·»åŠ é‡è¯•æœºåˆ¶

### ç¬¬ä¸‰é˜¶æ®µï¼šç›‘æ§å’Œä¼˜åŒ– (1-2å‘¨)
1. æ·»åŠ ç›‘æ§æŒ‡æ ‡
2. å®ç°å¥åº·æ£€æŸ¥
3. æ€§èƒ½ä¼˜åŒ–

### ç¬¬å››é˜¶æ®µï¼šç”Ÿäº§éƒ¨ç½² (1å‘¨)
1. é…ç½®ç”Ÿäº§ç¯å¢ƒ
2. éƒ¨ç½²å’Œæµ‹è¯•
3. ç›‘æ§å’Œå‘Šè­¦

## ğŸ¯ æ€»ç»“

é€šè¿‡å¼•å…¥ go-saga åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å¼ï¼Œæˆ‘ä»¬å¯ä»¥ï¼š

1. **ä¿è¯æ•°æ®ä¸€è‡´æ€§**ï¼šé€šè¿‡è¡¥å¿æ“ä½œç¡®ä¿æœ€ç»ˆä¸€è‡´æ€§
2. **æå‡ç³»ç»Ÿå¯é æ€§**ï¼šæ”¯æŒéƒ¨åˆ†å¤±è´¥å’Œè‡ªåŠ¨æ¢å¤
3. **æ”¹å–„ç”¨æˆ·ä½“éªŒ**ï¼šæä¾›å®æ—¶çš„æ‰§è¡ŒçŠ¶æ€å’Œè¿›åº¦è·Ÿè¸ª
4. **å¢å¼ºå¯è§‚æµ‹æ€§**ï¼šå®Œæ•´çš„æ‰§è¡Œè½¨è¿¹å’Œç›‘æ§æŒ‡æ ‡
5. **æ”¯æŒæ°´å¹³æ‰©å±•**ï¼šåˆ†å¸ƒå¼æ¶æ„æ”¯æŒé«˜å¹¶å‘åœºæ™¯

è¿™ä¸ªæ–¹æ¡ˆä¸º nancalacc é¡¹ç›®æä¾›äº†ä¸€ä¸ªå®Œæ•´çš„åˆ†å¸ƒå¼äº‹åŠ¡è§£å†³æ–¹æ¡ˆï¼Œæ—¢è§£å†³äº†å½“å‰çš„æ•°æ®ä¸€è‡´æ€§é—®é¢˜ï¼Œåˆä¸ºæœªæ¥çš„ä¸šåŠ¡æ‰©å±•å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚ 






3WCa&iG64#mxX!ow