### 配置管理
1. 本地配置 viper, 静态配置
   1. 服务启动必需的基础配置
   2. 开发环境的默认值
2. 环境变量
   1. 环境变量的优先级高于静态配置
   2. 容器化部署的标准化配置注入
   3. 敏感信息
3. 配置中心
   1. etcd
   2. consul
   3. 动态配置，实时变更，优先级最高

#### 具体步骤
1. 服务启动时：
  - 从本地文件加载默认配置（兜底）。
  - 环境变量覆盖关键配置（如 APP_ENV=prod）。
  - 连接配置中心，拉取完整配置（覆盖本地和环境变量）。
2. 运行时：
  - 配置中心推送变更时，服务动态更新内存配置。
  - 敏感配置始终通过环境变量/Secrets 获取，不存入配置中心。
3. 异常处理：
  - 配置中心不可用时，使用最后一次缓存的有效配置。
  - 本地记录配置版本号，便于故障排查。


#### 设计原则
##### 一 单一职责（Single Responsibility Principle, SRP）
- 核心思想
  - 每个微服务只负责一个独立的业务能力，且该能力的变更仅影响此服务。
- 技术实现
  - 领域驱动设计（DDD）
    1. 示例：电商系统中，订单服务负责订单生命周期，库存服务仅管理库存扣减。
    2. 通过限界上下文（Bounded Context）划分服务边界
- 违反后果
  - 服务膨胀：一个服务同时处理支付和物流，变更时影响范围不可控    

##### 松耦合（Loose Coupling）
- 核心思想
  - 服务间通过契约（Contract）交互，避免直接依赖内部实现
- 技术实现
  - 通信方式：
    同步：gRPC（强类型接口）+ Protobuf（IDL 定义）。 
    异步：Kafka 事件驱动（解耦生产者与消费者）。
  - 数据所有权：  
    每个服务独占自己的数据库，其他服务通过 API 访问数据。
    禁止跨服务直接连库（如订单服务不可直连库存库）
- 违反后果 
  - 级联故障：库存服务宕机导致订单服务无法响应。   
##### 自治性（Autonomy）
- 核心思想
  - 服务可独立开发、部署、扩展，不依赖其他服务的运行时状态。
- 技术实现
  - 独立部署单元，每个服务对应独立的 K8s Deployment 和 CI/CD 流水线 
  - 自包含数据，使用 Database per Service 模式，订单服务独占 order_db
  - 客户端负载均衡，gRPC 内置负载均衡
- 违反后果
  - 必须同时部署订单和支付服务才能生效新功能      
##### 容错性（Fault Tolerance）
- 核心思想  
  - 设计系统时假设依赖服务会失败，并制定降级策略。
- 技术实现
  - 熔断模式，使用 hystrix-go 或 sentinel-golang
  - 降级策略，支付服务不可用时，允许提交订单但标记为"待支付"
  - 重试机制， 指数退避重试（github.com/cenkalti/backoff/v4）：
  - 重试机制设计不当会导致请求指数级放大
    1. 只在调用链的最顶层发起重试，下层禁用重度或透传重试
       HTTP/gRPC 头传递重试标记
       OpenTelemetry 上下文传播
    2. 退避策略（Backoff）优化 
       指数退避 + 随机抖动
    3. 推荐 链路级重试控制 + 幂等设计  
- 违反后果
  雪崩效应：一个服务故障导致整个系统崩溃

##### 演进式设计（Evolutionary Design）
- 逐步替换单体系统：
- 数据库解耦，初步共享，逐步拆分
- 违反后果
  技术债务：过早拆分导致维护成本激增。

##### 安全设计（Security by Design）
- 核心思想
  - 零信任网络，服务间 mTLS 双向认证
  - 最小权限原则，K8s ServiceAccount 仅授权必要权限
- 违反后果
  - 数据泄露：数据库密码硬编码在代码中






    
