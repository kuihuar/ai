
1. Tree, Binary Tree, Binary Search Tree
2. Graph

- Linked List 是特殊化的 Tree
- Tree 是特殊化的 Graph

### Binary Search Tree
- 左子树所有节点的值小于根节点的值
- 右子树所有节点的值大于根节点的值
- 左右子树也分别为二叉搜索树
- 空树也是二叉搜索树

### Binary Tree
- 每个节点最多有两个子节点
- 空树也是二叉树
- 高度：从根节点到最深叶节点的最长路径上的边数。
- 深度：从根节点到某个特定节点的路径上的边数。
- 叶子节点：没有子节点的节点。

       A
      / \
     B   C
    / \   \
   D   E   F
      /
     G
1. 树的高度：3（树的高度是从根节点到最深的叶子节点的最长路径上的边的数量）
2. 节点的深度 
   - A 的深度：0（根节点的深度为 0）
   - B 的深度：1（从根节点到 B 的路径上有一条边）
   - E 的深度：2（从根节点到 E 的路径上有两条边）
   - G 的深度：3（从根节点到 G 的路径上有三条边）
3. 叶子节点
   - 叶子节点：D、F、G    
4. 树的层数：4
   - 定义：树的层数是树中节点的层次，从根节点开始，根节点为第一层，子节点为第二层，依此类推。 
   - 树的层数：4
   - 节点的层数：
     - A 的层数：1（根节点的层数为 1）
     - B 的层数：2（从根节点到 B 的路径上有一条边，所以 B 的层数为 2）
     - E 的层数：3（从根节点到 E 的路径上有两条边，所以 E 的层数为 3）
     - G 的层数：4（从根节点到 G 的路径上有三条边，所以 G 的层数为 4）
5. 树的宽度：4
   - 定义：树的宽度是指同一层上的节点数的最大值。

Red-Black Tree and AVL Tree and Splay Tree 在最坏情况下的时间复杂度都是 O(log n)，但是它们的实现方式和性质不同，导致它们在实际应用中具有不同的性能。


#### 查找最近公共祖先（二叉树）


1. 递归
   - 终止条件：
     - 当 root 为空时，返回 None
     - 当 root 等于 p 或 q 时，返回 root
   - 递归左子树
   - 递归右子树
   - 如果 left 和 right 都不为空，说明 p 和 q 分别在 root 的左右子树中，root 就是最近公共祖先
   - 如果 left 为空，说明 p 和 q 都不在 root 的左子树中，返回 right
   - 如果 right 为空，说明 p 和 q 都不在 root 的右子树中，返回 left
   - 时间复杂度：O(n)，其中 n 是二叉树的节点数。在最坏情况下，我们需要访问二叉树的所有节点。
   - 空间复杂度：O(n)，其中 n 是二叉树的节点数。空间复杂度主要取决于递归调用的栈空间。
```go
func LowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
	if root == nil {
		return root
	}
	if p.Val == root.Val || q.Val == root.Val {
		fmt.Printf("finded root: %+v, p: %v, q: %v \n", root, p, q)
		return root
	}
	left := LowestCommonAncestor(root.Left, p, q)
	right := LowestCommonAncestor(root.Right, p, q)

	if left == nil {
		fmt.Printf("find left eq nil, return right: %+v\n", right)
		return right
	}
	if right == nil {
		fmt.Printf("find right eq nil, return left: %+v\n", left)
		return left
	}
	// left != nil && right != nil
	fmt.Printf("finded left and right eq nil return root: %+v\n", root)
	return root
}
```

### 例子
        3
      /   \
     5     1
    / \   / \
   6   2 0   8
      / \
     7   4
p=7,q=8
#### 步骤1：从根节点3开始
1. 当前节点: 3（Val=3）
    - 检查是否匹配 p 或 q：否。
    - 递归左子树（节点5）。
    - 递归右子树（节点1）。
#### 步骤2：递归左子树（节点5）
2. 当前节点: 5（Val=5）
    - 检查是否匹配 p 或 q：否。
    - 递归左子树（节点6）。
    - 递归右子树（节点2）。
#### 步骤3：递归左子树（节点6）
3. 当前节点: 6（Val=6）
    - 检查是否匹配 p 或 q：否。
    - 左子树为空，返回 nil。
    - 右子树为空，返回 nil。
    - 合并结果: left = nil, right = nil → 返回 nil。

#### 步骤4：递归右子树（节点2）
4. 当前节点: 2（Val=2）

   - 检查是否匹配 p 或 q：否。

   - 递归左子树（节点7）。

   - 递归右子树（节点4）。

#### 步骤5：递归左子树（节点7）
7. 当前节点: 7（Val=7）

    - 匹配 p（Val=7）→ 直接返回节点7。

#### 步骤6：递归右子树（节点4）
6. 当前节点: 4（Val=4）

   - 检查是否匹配 p 或 q：否。

   - 左子树为空，返回 nil。

   - 右子树为空，返回 nil。

   - 合并结果: left = nil, right = nil → 返回 nil。

#### 步骤7：合并节点2的结果
7. 当前节点: 2

   - left = 7（非空）, right = nil（空）。

   - 规则: 若右为空，返回左子树结果。

   - 返回节点7（来自左子树）。

#### 步骤8：合并节点5的结果
8. 当前节点: 5

   - left = nil（来自节点6）, right = 7（来自节点2）。

   - 规则: 若左为空，返回右子树结果。

   - 返回节点7（来自右子树）。

#### 步骤9：递归右子树（节点1）
9. 当前节点: 1（Val=1）

   - 检查是否匹配 p 或 q：否。

   - 递归左子树（节点0）。

   - 递归右子树（节点8）。

#### 步骤10：递归左子树（节点0）
10. 当前节点: 0（Val=0）

    - 检查是否匹配 p 或 q：否。
    - 左子树为空，返回 nil。
    - 右子树为空，返回 nil。
    - 合并结果: left = nil, right = nil → 返回 nil。

#### 步骤11：递归右子树（节点8）
11. 当前节点: 8（Val=8）
    - 匹配 q（Val=8）→ 直接返回节点8。

#### 步骤12：合并节点1的结果
12. 当前节点: 1

    - left = nil（来自节点0）, right = 8（来自节点8）。
    - 规则: 若左为空，返回右子树结果。
    - 返回节点8（来自右子树）。

#### 步骤13：合并根节点3的结果
13. 当前节点: 3

    - left = 7（来自节点5的递归）, right = 8（来自节点1的递归）。
    - 规则: 若左右均非空，返回当前节点（根节点）。
    - 最终结果: 返回节点3。

#### 关键结论

- LCA 是根节点3：因为 p=7 位于左子树，q=8 位于右子树，它们的最近公共祖先是根节点3。
- 递归路径：算法通过后序遍历自底向上合并结果，最终确定根节点为 LCA。

#### 验证逻辑
- 节点7的路径: 3 → 5 → 2 → 7。
- 节点8的路径: 3 → 1 → 8。
- 首个公共祖先: 节点3是两者路径的第一个交点。



#### 二叉树的最近公共祖先迭代实现的步骤
```go
func LowestCommonAncestor2(root, p, q *TreeNode) *TreeNode {

	for root != nil {
		if p.Val < root.Val && q.Val < root.Val {
			root = root.Left
		}
		if p.Val > root.Val && q.Val > root.Val {
			root = root.Right
		}
		return root
	}
	return nil
}
```
#### 步骤 root = [6,2,8,0,4,7,9,null,null,3,5]， p=3,q=5这次的步骤呢？

- 结构
       6
      / \
     2   8
    / \ / \
   0  4 7  9
     / \
    3   5

- 迭代步骤
1. 初始化：

- root 指向树的根节点（值为 6）。
- p 的值为 3，q 的值为 5。
2. 第一轮迭代：

- 检查 p 和 q 的值：
  - 3 < 6（左子树），所以进入左子树。
  - 5 < 6（左子树），所以继续进入左子树。
- 更新 root 为 2。
3. 第二轮迭代：

- 检查新的 root（值为 2）：
  - 3 > 2（右子树），所以进入右子树。
  - 5 > 2（右子树），所以继续进入右子树。
- 更新 root 为 4。
4. 第三轮迭代：

- 检查新的 root（值为 4）：
  - 3 < 4（左子树），所以进入左子树。
  - 5 > 4（右子树），所以进入右子树。
- 由于 p 和 q 分别在 4 的两侧，root（值为 4）就是它们的最低公共祖先，直接返回 root。
5. 返回结果：

- 函数返回值为节点 4，这就是 p 和 q 的最近公共祖先。

#### 步骤 root = [6,2,8,0,4,7,9,null,null,3,5]， p=3,q=7这次的步骤呢？
- 第一轮直接返回6

