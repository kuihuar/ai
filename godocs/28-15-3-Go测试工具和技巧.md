# Go 测试工具和技巧

## 一、测试工具

### 1.1 go test 命令

#### 基本用法

```bash
# 运行当前包的测试
go test

# 运行所有包的测试
go test ./...

# 运行特定包的测试
go test ./internal/user

# 运行特定测试函数
go test -run TestGetUser

# 运行匹配模式的测试
go test -run TestGetUser.*Success

# 显示详细输出
go test -v

# 显示测试覆盖率
go test -cover

# 生成覆盖率报告
go test -coverprofile=coverage.out
go tool cover -html=coverage.out
```

#### 常用标志

```bash
# -v: 详细输出
go test -v

# -run: 运行匹配的测试
go test -run TestGetUser

# -cover: 显示覆盖率
go test -cover

# -coverprofile: 生成覆盖率文件
go test -coverprofile=coverage.out

# -covermode: 覆盖率模式（atomic, count, set）
go test -covermode=atomic

# -parallel: 并行测试数量
go test -parallel 4

# -timeout: 测试超时时间
go test -timeout 30s

# -count: 运行测试次数
go test -count=3

# -race: 竞态检测
go test -race

# -short: 跳过长时间运行的测试
go test -short

# -tags: 指定 build tags
go test -tags=integration
```

### 1.2 测试覆盖率工具

#### 查看覆盖率

```bash
# 基本覆盖率
go test -cover ./...

# 详细覆盖率（按包）
go test -cover ./... | grep -E "(PASS|FAIL|coverage)"

# 生成覆盖率文件
go test -coverprofile=coverage.out ./...

# HTML 报告
go tool cover -html=coverage.out -o coverage.html

# 函数级别覆盖率
go tool cover -func=coverage.out
```

#### 覆盖率阈值

```bash
# 设置覆盖率阈值（需要脚本）
#!/bin/bash
coverage=$(go test -cover ./... | grep total | awk '{print $5}' | sed 's/%//')
threshold=80

if (( $(echo "$coverage < $threshold" | bc -l) )); then
    echo "Coverage $coverage% is below threshold $threshold%"
    exit 1
fi
```

### 1.3 竞态检测工具

```bash
# 运行竞态检测
go test -race ./...

# 编译时启用竞态检测
go build -race

# 运行程序时检测竞态
go run -race main.go
```

**注意事项**:
- 竞态检测会增加 2-10 倍的执行时间
- 会增加 5-10 倍的内存使用
- 只在测试和开发时使用，不要在生产环境使用

### 1.4 基准测试工具

```bash
# 运行所有基准测试
go test -bench=. ./...

# 运行特定基准测试
go test -bench=BenchmarkAdd

# 显示内存分配
go test -bench=. -benchmem

# 比较基准测试
go test -bench=. -benchmem -count=5

# 生成 CPU profile
go test -bench=. -cpuprofile=cpu.prof

# 生成内存 profile
go test -bench=. -memprofile=mem.prof
```

## 二、性能分析工具

### 2.1 pprof

#### 基本使用

```go
// ✅ 在代码中添加 pprof
import _ "net/http/pprof"

func main() {
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    // ...
}
```

#### 分析 CPU

```bash
# 生成 CPU profile
go test -bench=. -cpuprofile=cpu.prof

# 分析 CPU profile
go tool pprof cpu.prof

# 在 pprof 交互式界面中
(pprof) top
(pprof) list FunctionName
(pprof) web
```

#### 分析内存

```bash
# 生成内存 profile
go test -bench=. -memprofile=mem.prof

# 分析内存 profile
go tool pprof mem.prof

# 在 pprof 交互式界面中
(pprof) top
(pprof) list FunctionName
(pprof) web
```

#### Web 界面

```bash
# 启动 Web 界面
go tool pprof -http=:8080 cpu.prof

# 访问 http://localhost:8080 查看可视化报告
```

### 2.2 实时性能分析

```go
// ✅ 实时性能分析
import (
    _ "net/http/pprof"
    "net/http"
)

func main() {
    // 启动 pprof 服务器
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // 应用代码
    // ...
}

// 使用方式
// 1. 访问 http://localhost:6060/debug/pprof/
// 2. 下载 profile: curl http://localhost:6060/debug/pprof/profile?seconds=30 > cpu.prof
// 3. 分析: go tool pprof cpu.prof
```

## 三、测试辅助库

### 3.1 testify

#### 安装

```bash
go get github.com/stretchr/testify/assert
go get github.com/stretchr/testify/require
go get github.com/stretchr/testify/mock
go get github.com/stretchr/testify/suite
```

#### assert 包

```go
// ✅ 使用 assert
import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestAdd(t *testing.T) {
    result := Add(1, 2)
    assert.Equal(t, 3, result)
    assert.NotNil(t, result)
    assert.NoError(t, err)
    assert.Contains(t, "hello world", "world")
}
```

#### require 包

```go
// ✅ 使用 require（失败时立即停止）
import (
    "testing"
    "github.com/stretchr/testify/require"
)

func TestGetUser(t *testing.T) {
    user, err := GetUser(1)
    require.NoError(t, err)  // 失败时立即停止
    require.NotNil(t, user)
    require.Equal(t, "Test User", user.Name)
}
```

#### suite 包

```go
// ✅ 使用 suite 组织测试
import (
    "testing"
    "github.com/stretchr/testify/suite"
)

type UserTestSuite struct {
    suite.Suite
    db *sql.DB
}

func (s *UserTestSuite) SetupTest() {
    // 每个测试前的设置
    s.db = setupTestDB()
}

func (s *UserTestSuite) TearDownTest() {
    // 每个测试后的清理
    s.db.Close()
}

func (s *UserTestSuite) TestGetUser() {
    user, err := GetUser(s.db, 1)
    s.NoError(err)
    s.NotNil(user)
}

func TestUserTestSuite(t *testing.T) {
    suite.Run(t, new(UserTestSuite))
}
```

### 3.2 gomock

#### 安装和生成

```bash
# 安装 mockgen
go install github.com/golang/mock/mockgen@latest

# 生成 Mock
mockgen -source=interface.go -destination=mock_interface.go
```

#### 使用示例

```go
// ✅ 使用 gomock
import (
    "testing"
    "github.com/golang/mock/gomock"
)

func TestService(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    
    mockDB := NewMockDatabase(ctrl)
    mockDB.EXPECT().
        GetUser(1).
        Return(&User{ID: 1, Name: "Test"}, nil).
        Times(1)
    
    service := NewService(mockDB)
    user, err := service.GetUser(1)
    
    assert.NoError(t, err)
    assert.Equal(t, "Test", user.Name)
}
```

### 3.3 httptest

```go
// ✅ 使用 httptest 测试 HTTP
import (
    "net/http"
    "net/http/httptest"
    "testing"
)

func TestHandler(t *testing.T) {
    handler := http.HandlerFunc(UserHandler)
    
    req := httptest.NewRequest("GET", "/user/1", nil)
    w := httptest.NewRecorder()
    
    handler.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusOK, w.Code)
    assert.Contains(t, w.Body.String(), "Test User")
}
```

## 四、测试技巧

### 4.1 测试表格驱动

```go
// ✅ 表驱动测试
func TestValidateEmail(t *testing.T) {
    tests := []struct {
        name    string
        email   string
        wantErr bool
    }{
        {"valid email", "test@example.com", false},
        {"invalid email", "invalid", true},
        {"empty email", "", true},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ValidateEmail(tt.email)
            if (err != nil) != tt.wantErr {
                t.Errorf("ValidateEmail() error = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}
```

### 4.2 测试辅助函数

```go
// ✅ 测试辅助函数
func assertEqual(t *testing.T, got, want interface{}) {
    t.Helper()
    if got != want {
        t.Errorf("got %v, want %v", got, want)
    }
}

func createTestUser(t *testing.T) *User {
    t.Helper()
    return &User{
        ID:   1,
        Name: "Test User",
    }
}
```

### 4.3 测试清理

```go
// ✅ 使用 t.Cleanup
func TestWithCleanup(t *testing.T) {
    db := setupTestDB(t)
    t.Cleanup(func() {
        db.Close()
    })
    
    // 测试代码
}

// ✅ 使用 defer
func TestWithDefer(t *testing.T) {
    db := setupTestDB(t)
    defer db.Close()
    
    // 测试代码
}
```

### 4.4 跳过测试

```go
// ✅ 跳过测试
func TestLongRunning(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping long-running test")
    }
    
    // 长时间运行的测试
}

// 运行: go test -short 会跳过这个测试
```

### 4.5 并行测试

```go
// ✅ 并行测试
func TestA(t *testing.T) {
    t.Parallel()
    // 测试代码
}

func TestB(t *testing.T) {
    t.Parallel()
    // 测试代码
}

// 运行: go test -parallel 4
```

## 五、测试最佳实践总结

### 5.1 工具选择

| 工具 | 用途 | 推荐度 |
|------|------|--------|
| **go test** | 基本测试运行 | ⭐⭐⭐⭐⭐ |
| **testify** | 断言和测试组织 | ⭐⭐⭐⭐ |
| **gomock** | Mock 生成 | ⭐⭐⭐⭐ |
| **httptest** | HTTP 测试 | ⭐⭐⭐⭐⭐ |
| **pprof** | 性能分析 | ⭐⭐⭐⭐⭐ |
| **testcontainers** | 容器化测试 | ⭐⭐⭐⭐ |

### 5.2 测试命令总结

```bash
# 基本测试
go test ./...

# 详细输出
go test -v ./...

# 覆盖率
go test -cover ./...

# 竞态检测
go test -race ./...

# 基准测试
go test -bench=. -benchmem ./...

# 集成测试
go test -tags=integration ./...

# 并行测试
go test -parallel 4 ./...

# 超时设置
go test -timeout 30s ./...
```

### 5.3 测试文件组织

```
project/
├── user.go
├── user_test.go              # 单元测试
├── user_integration_test.go  # 集成测试
├── user_bench_test.go        # 基准测试
└── testdata/                 # 测试数据
    └── fixtures.json
```

记住这些工具和技巧，可以编写更高效、更可靠的测试！

