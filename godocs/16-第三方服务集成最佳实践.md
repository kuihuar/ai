# 第三方服务集成最佳实践

## 概述

本文档说明如何在 GoFrame 项目中集成第三方服务（如支付宝、钉钉、微信等）。

## 架构设计

### 推荐架构

```
Controller → Service → Client (第三方服务客户端) → 第三方API
```

### 目录结构

```
internal/
  ├── client/              ← 第三方服务客户端层
  │   ├── alipay/         ← 支付宝客户端
  │   │   ├── client.go   ← 客户端实现
  │   │   └── types.go    ← 类型定义
  │   ├── dingtalk/       ← 钉钉客户端
  │   │   ├── client.go
  │   │   └── types.go
  │   └── wechat/         ← 微信客户端
  │       ├── client.go
  │       └── types.go
  ├── service/
  ├── controller/
  └── model/
```

## 实现步骤

### 1. 创建Client层

**职责**：
- 封装第三方API调用
- 处理请求/响应转换
- 错误处理和重试
- 配置管理

### 2. 在Service层调用Client

**职责**：
- 业务逻辑编排
- 调用Client层
- 数据转换

### 3. 配置管理

**职责**：
- 第三方服务配置
- 密钥管理
- 环境区分

## 完整示例：支付宝集成

### 1. 配置文件

```yaml
# manifest/config/config.yaml
# 第三方服务配置
thirdparty:
  alipay:
    appId: "your_app_id"
    appPrivateKey: "your_private_key"
    alipayPublicKey: "alipay_public_key"
    gateway: "https://openapi.alipay.com/gateway.do"
    timeout: "30s"
  dingtalk:
    appKey: "your_app_key"
    appSecret: "your_app_secret"
    gateway: "https://oapi.dingtalk.com"
    timeout: "30s"
```

### 2. Client层实现

```go
// internal/client/alipay/types.go
package alipay

// PayRequest 支付请求
type PayRequest struct {
	OutTradeNo  string  `json:"out_trade_no"`  // 商户订单号
	Subject     string  `json:"subject"`        // 订单标题
	TotalAmount float64 `json:"total_amount"`  // 订单总金额
	ReturnUrl   string  `json:"return_url"`    // 同步回调地址
	NotifyUrl   string  `json:"notify_url"`    // 异步回调地址
}

// PayResponse 支付响应
type PayResponse struct {
	TradeNo    string `json:"trade_no"`     // 支付宝交易号
	OutTradeNo string `json:"out_trade_no"` // 商户订单号
	PayUrl     string `json:"pay_url"`      // 支付链接
}

// Config 支付宝配置
type Config struct {
	AppId          string
	AppPrivateKey  string
	AlipayPublicKey string
	Gateway        string
	Timeout        string
}
```

```go
// internal/client/alipay/client.go
package alipay

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/gclient"
)

type Client struct {
	config *Config
	httpClient *gclient.Client
}

// NewClient 创建支付宝客户端
func NewClient(config *Config) *Client {
	timeout, _ := time.ParseDuration(config.Timeout)
	if timeout == 0 {
		timeout = 30 * time.Second
	}
	
	return &Client{
		config: config,
		httpClient: g.Client().Timeout(timeout),
	}
}

// Pay 发起支付
func (c *Client) Pay(ctx context.Context, req *PayRequest) (*PayResponse, error) {
	// 1. 构建请求参数
	params := c.buildParams(req)
	
	// 2. 签名
	sign := c.sign(params)
	params["sign"] = sign
	
	// 3. 调用支付宝API
	resp, err := c.httpClient.Post(ctx, c.config.Gateway, params)
	if err != nil {
		return nil, fmt.Errorf("调用支付宝API失败: %w", err)
	}
	defer resp.Close()
	
	// 4. 解析响应
	var result struct {
		AlipayTradePrecreateResponse struct {
			Code    string `json:"code"`
			Msg     string `json:"msg"`
			TradeNo string `json:"trade_no"`
			OutTradeNo string `json:"out_trade_no"`
			QrCode  string `json:"qr_code"`
		} `json:"alipay_trade_precreate_response"`
		Sign string `json:"sign"`
	}
	
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("解析响应失败: %w", err)
	}
	
	// 5. 验证签名
	if !c.verifySign(result.Sign, result.AlipayTradePrecreateResponse) {
		return nil, fmt.Errorf("签名验证失败")
	}
	
	// 6. 检查业务结果
	if result.AlipayTradePrecreateResponse.Code != "10000" {
		return nil, fmt.Errorf("支付宝返回错误: %s", result.AlipayTradePrecreateResponse.Msg)
	}
	
	return &PayResponse{
		TradeNo:    result.AlipayTradePrecreateResponse.TradeNo,
		OutTradeNo: result.AlipayTradePrecreateResponse.OutTradeNo,
		PayUrl:     result.AlipayTradePrecreateResponse.QrCode,
	}, nil
}

// buildParams 构建请求参数
func (c *Client) buildParams(req *PayRequest) map[string]interface{} {
	return map[string]interface{}{
		"app_id":    c.config.AppId,
		"method":    "alipay.trade.precreate",
		"charset":   "utf-8",
		"sign_type": "RSA2",
		"timestamp":  time.Now().Format("2006-01-02 15:04:05"),
		"version":   "1.0",
		"biz_content": map[string]interface{}{
			"out_trade_no": req.OutTradeNo,
			"subject":      req.Subject,
			"total_amount": req.TotalAmount,
			"return_url":   req.ReturnUrl,
			"notify_url":   req.NotifyUrl,
		},
	}
}

// sign 签名（简化示例，实际需要使用RSA签名）
func (c *Client) sign(params map[string]interface{}) string {
	// 实际实现需要使用RSA私钥签名
	// 这里只是示例
	return "signature_placeholder"
}

// verifySign 验证签名
func (c *Client) verifySign(sign string, data interface{}) bool {
	// 实际实现需要使用RSA公钥验证
	// 这里只是示例
	return true
}
```

### 3. Client工厂函数

```go
// internal/client/alipay/factory.go
package alipay

import (
	"github.com/gogf/gf/v2/frame/g"
)

var defaultClient *Client

// Init 初始化支付宝客户端（从配置加载）
func Init() error {
	config := &Config{
		AppId:          g.Cfg().MustGet("thirdparty.alipay.appId").String(),
		AppPrivateKey:  g.Cfg().MustGet("thirdparty.alipay.appPrivateKey").String(),
		AlipayPublicKey: g.Cfg().MustGet("thirdparty.alipay.alipayPublicKey").String(),
		Gateway:        g.Cfg().MustGet("thirdparty.alipay.gateway").String(),
		Timeout:        g.Cfg().MustGet("thirdparty.alipay.timeout", "30s").String(),
	}
	
	defaultClient = NewClient(config)
	return nil
}

// GetClient 获取默认客户端
func GetClient() *Client {
	return defaultClient
}
```

### 4. Service层调用Client

```go
// internal/service/payment.go
package service

import (
	"context"
	"errors"
	
	"hz/internal/client/alipay"
	"hz/internal/dao"
)

type IPayment interface {
	CreatePayment(ctx context.Context, orderId string, amount float64) (payUrl string, err error)
	QueryPayment(ctx context.Context, tradeNo string) (status string, err error)
}

type paymentImpl struct{}

var Payment = paymentImpl{}

// CreatePayment 创建支付
func (s *paymentImpl) CreatePayment(ctx context.Context, orderId string, amount float64) (payUrl string, err error) {
	// 1. 业务逻辑：检查订单
	order, err := dao.Order.GetById(ctx, orderId)
	if err != nil {
		return "", err
	}
	if order == nil {
		return "", errors.New("订单不存在")
	}
	
	// 2. 调用支付宝客户端
	req := &alipay.PayRequest{
		OutTradeNo:  orderId,
		Subject:     order.Subject,
		TotalAmount: amount,
		ReturnUrl:   "https://your-domain.com/payment/return",
		NotifyUrl:   "https://your-domain.com/payment/notify",
	}
	
	resp, err := alipay.GetClient().Pay(ctx, req)
	if err != nil {
		return "", err
	}
	
	// 3. 保存支付记录
	// ...
	
	return resp.PayUrl, nil
}
```

### 5. Controller层

```go
// internal/controller/payment/payment_v1_create.go
package payment

import (
	"context"
	v1 "hz/api/payment/v1"
	"hz/internal/service"
)

func (c *ControllerV1) Create(ctx context.Context, req *v1.CreatePaymentReq) (res *v1.CreatePaymentRes, err error) {
	payUrl, err := service.Payment.CreatePayment(ctx, req.OrderId, req.Amount)
	if err != nil {
		return nil, err
	}
	
	return &v1.CreatePaymentRes{
		PayUrl: payUrl,
	}, nil
}
```

## 完整示例：钉钉集成

### 1. Client层

```go
// internal/client/dingtalk/types.go
package dingtalk

// SendMessageRequest 发送消息请求
type SendMessageRequest struct {
	AgentId    int64  `json:"agent_id"`
	UserIds    []string `json:"userid_list"`
	MsgType    string `json:"msgtype"`
	Text       *TextMessage `json:"text,omitempty"`
	Markdown   *MarkdownMessage `json:"markdown,omitempty"`
}

type TextMessage struct {
	Content string `json:"content"`
}

type MarkdownMessage struct {
	Title string `json:"title"`
	Text  string `json:"text"`
}

// SendMessageResponse 发送消息响应
type SendMessageResponse struct {
	TaskId string `json:"task_id"`
}

// Config 钉钉配置
type Config struct {
	AppKey    string
	AppSecret string
	Gateway   string
	Timeout   string
}
```

```go
// internal/client/dingtalk/client.go
package dingtalk

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/gclient"
)

type Client struct {
	config     *Config
	httpClient *gclient.Client
	accessToken string
	tokenExpire time.Time
}

// NewClient 创建钉钉客户端
func NewClient(config *Config) *Client {
	timeout, _ := time.ParseDuration(config.Timeout)
	if timeout == 0 {
		timeout = 30 * time.Second
	}
	
	return &Client{
		config:     config,
		httpClient: g.Client().Timeout(timeout),
	}
}

// getAccessToken 获取访问令牌
func (c *Client) getAccessToken(ctx context.Context) (string, error) {
	// 如果token未过期，直接返回
	if c.accessToken != "" && time.Now().Before(c.tokenExpire) {
		return c.accessToken, nil
	}
	
	// 调用钉钉API获取token
	url := fmt.Sprintf("%s/gettoken?appkey=%s&appsecret=%s", 
		c.config.Gateway, c.config.AppKey, c.config.AppSecret)
	
	resp, err := c.httpClient.Get(ctx, url)
	if err != nil {
		return "", fmt.Errorf("获取access_token失败: %w", err)
	}
	defer resp.Close()
	
	var result struct {
		Errcode     int    `json:"errcode"`
		Errmsg      string `json:"errmsg"`
		AccessToken string `json:"access_token"`
		ExpiresIn   int    `json:"expires_in"`
	}
	
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", fmt.Errorf("解析响应失败: %w", err)
	}
	
	if result.Errcode != 0 {
		return "", fmt.Errorf("获取access_token失败: %s", result.Errmsg)
	}
	
	// 缓存token
	c.accessToken = result.AccessToken
	c.tokenExpire = time.Now().Add(time.Duration(result.ExpiresIn-60) * time.Second) // 提前60秒过期
	
	return c.accessToken, nil
}

// SendMessage 发送消息
func (c *Client) SendMessage(ctx context.Context, req *SendMessageRequest) (*SendMessageResponse, error) {
	// 1. 获取access_token
	token, err := c.getAccessToken(ctx)
	if err != nil {
		return nil, err
	}
	
	// 2. 构建请求
	url := fmt.Sprintf("%s/topapi/message/corpconversation/asyncsend_v2?access_token=%s", 
		c.config.Gateway, token)
	
	// 3. 调用钉钉API
	resp, err := c.httpClient.Post(ctx, url, req)
	if err != nil {
		return nil, fmt.Errorf("调用钉钉API失败: %w", err)
	}
	defer resp.Close()
	
	// 4. 解析响应
	var result struct {
		Errcode int    `json:"errcode"`
		Errmsg  string `json:"errmsg"`
		TaskId  string `json:"task_id"`
	}
	
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("解析响应失败: %w", err)
	}
	
	if result.Errcode != 0 {
		return nil, fmt.Errorf("钉钉返回错误: %s", result.Errmsg)
	}
	
	return &SendMessageResponse{
		TaskId: result.TaskId,
	}, nil
}
```

### 2. Service层

```go
// internal/service/notification.go
package service

import (
	"context"
	"hz/internal/client/dingtalk"
)

type INotification interface {
	SendDingTalkMessage(ctx context.Context, userIds []string, content string) error
}

type notificationImpl struct{}

var Notification = notificationImpl{}

func (s *notificationImpl) SendDingTalkMessage(ctx context.Context, userIds []string, content string) error {
	req := &dingtalk.SendMessageRequest{
		AgentId: 123456, // 从配置获取
		UserIds: userIds,
		MsgType: "text",
		Text: &dingtalk.TextMessage{
			Content: content,
		},
	}
	
	_, err := dingtalk.GetClient().SendMessage(ctx, req)
	return err
}
```

## 最佳实践

### 1. 接口抽象

```go
// internal/client/alipay/interface.go
package alipay

type IPaymentClient interface {
	Pay(ctx context.Context, req *PayRequest) (*PayResponse, error)
	Query(ctx context.Context, tradeNo string) (*QueryResponse, error)
	Refund(ctx context.Context, req *RefundRequest) (*RefundResponse, error)
}
```

**优势**：
- 便于测试（可以Mock）
- 便于切换实现
- 符合依赖倒置原则

### 2. 错误处理

```go
// internal/client/alipay/errors.go
package alipay

import "errors"

var (
	ErrInvalidConfig = errors.New("配置无效")
	ErrSignFailed    = errors.New("签名失败")
	ErrAPIError      = errors.New("API调用失败")
	ErrNetworkError  = errors.New("网络错误")
)
```

### 3. 重试机制

```go
// internal/client/alipay/client.go
func (c *Client) PayWithRetry(ctx context.Context, req *PayRequest, maxRetries int) (*PayResponse, error) {
	var lastErr error
	for i := 0; i < maxRetries; i++ {
		resp, err := c.Pay(ctx, req)
		if err == nil {
			return resp, nil
		}
		lastErr = err
		// 指数退避
		time.Sleep(time.Duration(i+1) * time.Second)
	}
	return nil, lastErr
}
```

### 4. 配置管理

```go
// internal/client/alipay/factory.go
func InitFromConfig() (*Client, error) {
	cfg := g.Cfg()
	
	config := &Config{
		AppId:          cfg.MustGet("thirdparty.alipay.appId").String(),
		AppPrivateKey:  cfg.MustGet("thirdparty.alipay.appPrivateKey").String(),
		AlipayPublicKey: cfg.MustGet("thirdparty.alipay.alipayPublicKey").String(),
		Gateway:        cfg.MustGet("thirdparty.alipay.gateway", "https://openapi.alipay.com/gateway.do").String(),
		Timeout:        cfg.MustGet("thirdparty.alipay.timeout", "30s").String(),
	}
	
	// 验证配置
	if config.AppId == "" {
		return nil, ErrInvalidConfig
	}
	
	return NewClient(config), nil
}
```

### 5. 初始化顺序

```go
// main.go 或 cmd.go
func init() {
	// 初始化第三方服务客户端
	if err := alipay.Init(); err != nil {
		panic(fmt.Sprintf("初始化支付宝客户端失败: %v", err))
	}
	
	if err := dingtalk.Init(); err != nil {
		panic(fmt.Sprintf("初始化钉钉客户端失败: %v", err))
	}
}
```

## 目录结构示例

```
internal/
  ├── client/
  │   ├── alipay/
  │   │   ├── client.go      ← 客户端实现
  │   │   ├── types.go       ← 类型定义
  │   │   ├── factory.go     ← 工厂函数
  │   │   └── errors.go      ← 错误定义
  │   ├── dingtalk/
  │   │   ├── client.go
  │   │   ├── types.go
  │   │   └── factory.go
  │   └── wechat/
  │       ├── client.go
  │       └── types.go
  ├── service/
  │   ├── payment.go         ← 支付服务（调用alipay client）
  │   └── notification.go    ← 通知服务（调用dingtalk client）
  └── controller/
      ├── payment/
      └── notification/
```

## 总结

### 关键原则

1. **Client层** → 封装第三方API调用
2. **Service层** → 业务逻辑编排，调用Client
3. **配置管理** → 统一配置，环境区分
4. **错误处理** → 统一错误定义和处理
5. **接口抽象** → 便于测试和切换

### 优势

- ✅ **职责分离**：Client层专门处理第三方API
- ✅ **易于测试**：可以Mock Client层
- ✅ **易于维护**：第三方服务变化只需修改Client层
- ✅ **可复用**：Client可被多个Service使用

**记住**：第三方服务集成应该通过独立的Client层，而不是直接在Service层调用HTTP客户端！

