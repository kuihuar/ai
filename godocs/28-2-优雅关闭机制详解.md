# 优雅关闭机制详解

## 一、什么是优雅关闭？

### 1.1 优雅关闭的概念

**优雅关闭（Graceful Shutdown）** 是指在停止服务器时：
1. **停止接收新请求**: 不再接受新的连接
2. **等待现有请求完成**: 让正在处理的请求正常完成
3. **清理资源**: 关闭数据库连接、释放资源等
4. **然后退出**: 所有请求处理完成后才退出

### 1.2 非优雅关闭的问题

```go
// ❌ 非优雅关闭：直接退出
func main() {
    server := &http.Server{
        Addr: ":8080",
        Handler: handler,
    }
    
    go server.ListenAndServe()
    
    // 直接退出，正在处理的请求会被中断
    os.Exit(0)
}
```

**问题**:
- 正在处理的请求会被中断
- 用户可能收到错误响应
- 数据可能不一致
- 资源可能没有正确释放

### 1.3 优雅关闭的优势

```go
// ✅ 优雅关闭：等待请求完成
func main() {
    server := &http.Server{
        Addr: ":8080",
        Handler: handler,
    }
    
    go server.ListenAndServe()
    
    // 等待停止信号
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
    <-sigChan
    
    // 优雅关闭：等待现有请求完成
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    server.Shutdown(ctx)
}
```

**优势**:
- 正在处理的请求可以正常完成
- 用户不会收到错误响应
- 数据保持一致
- 资源正确释放

## 二、Kratos 的优雅关闭实现

### 2.1 应用生命周期管理

```go
// app.go
func (a *App) Run() error {
    // 1. 启动前钩子
    for _, fn := range a.opts.beforeStart {
        if err = fn(sctx); err != nil {
            return err
        }
    }
    
    // 2. 并发启动所有服务器
    eg, ctx := errgroup.WithContext(sctx)
    for _, srv := range a.opts.servers {
        server := srv
        // 启动服务器
        eg.Go(func() error {
            return server.Start(octx)
        })
        // 停止服务器（等待停止信号）
        eg.Go(func() error {
            <-ctx.Done()  // 等待停止信号
            stopCtx := context.WithoutCancel(octx)
            if a.opts.stopTimeout > 0 {
                var cancel context.CancelFunc
                stopCtx, cancel = context.WithTimeout(stopCtx, a.opts.stopTimeout)
                defer cancel()
            }
            return server.Stop(stopCtx)  // 优雅停止
        })
    }
    
    // 3. 服务注册
    if a.opts.registrar != nil {
        a.opts.registrar.Register(rctx, instance)
    }
    
    // 4. 启动后钩子
    for _, fn := range a.opts.afterStart {
        if err = fn(sctx); err != nil {
            return err
        }
    }
    
    // 5. 等待停止信号
    c := make(chan os.Signal, 1)
    signal.Notify(c, a.opts.sigs...)
    eg.Go(func() error {
        select {
        case <-ctx.Done():
            return nil
        case <-c:
            return a.Stop()  // 收到信号，优雅停止
        }
    })
    
    return eg.Wait()
}
```

### 2.2 优雅停止实现

```go
// app.go
func (a *App) Stop() (err error) {
    // 1. 停止前钩子
    sctx := NewContext(a.ctx, a)
    for _, fn := range a.opts.beforeStop {
        err = fn(sctx)
    }
    
    // 2. 注销服务
    a.mu.Lock()
    instance := a.instance
    a.mu.Unlock()
    if a.opts.registrar != nil && instance != nil {
        ctx, cancel := context.WithTimeout(NewContext(a.ctx, a), a.opts.registrarTimeout)
        defer cancel()
        if err = a.opts.registrar.Deregister(ctx, instance); err != nil {
            return err
        }
    }
    
    // 3. 取消上下文（触发服务器停止）
    if a.cancel != nil {
        a.cancel()
    }
    
    // 4. 停止后钩子
    for _, fn := range a.opts.afterStop {
        err = fn(sctx)
    }
    
    return err
}
```

### 2.3 使用示例

```go
func main() {
    app := kratos.New(
        kratos.Name("helloworld"),
        kratos.Server(httpSrv, grpcSrv),
        kratos.Registrar(registry),
        kratos.StopTimeout(30*time.Second),  // 停止超时
        kratos.BeforeStop(func(ctx context.Context) error {
            // 停止前：关闭数据库连接
            return db.Close()
        }),
        kratos.AfterStop(func(ctx context.Context) error {
            // 停止后：清理资源
            return cleanup()
        }),
    )
    
    // 运行应用（自动处理优雅关闭）
    if err := app.Run(); err != nil {
        log.Fatal(err)
    }
}
```

## 三、GoFrame 的优雅关闭实现

### 3.1 优雅重启/关闭

```go
// internal/graceful/graceful.go
type Server struct {
    httpServer  *http.Server
    rawListener net.Listener
    status      *gtype.Int
    config      ServerConfig
}

// Shutdown 优雅关闭服务器
func (s *Server) Shutdown(ctx context.Context) {
    // 1. 设置超时
    timeoutCtx, cancel := context.WithTimeout(
        ctx,
        time.Duration(s.config.GracefulShutdownTimeout)*time.Second,
    )
    defer cancel()
    
    // 2. 关闭服务器（等待现有请求完成）
    if err := s.httpServer.Shutdown(timeoutCtx); err != nil {
        s.config.Logger.Errorf(
            "%d: %s server [%s] shutdown error: %v",
            gproc.Pid(),
            "HTTP",
            s.address,
            err,
        )
    }
}
```

### 3.2 优雅重启

```go
// GoFrame 支持优雅重启（零停机部署）
func (s *Server) Restart() error {
    // 1. 获取文件描述符
    fd := s.Fd()
    
    // 2. 启动新进程（传递文件描述符）
    // 新进程会继承文件描述符，继续监听同一端口
    
    // 3. 关闭旧进程
    // 旧进程等待现有请求完成后退出
    
    return nil
}
```

### 3.3 使用示例

```go
func main() {
    s := g.Server()
    s.Group("/", func(group *ghttp.RouterGroup) {
        group.GET("/hello", handler)
    })
    
    // 启动服务器（支持优雅关闭）
    s.Run()
    
    // 可以通过信号触发优雅关闭
    // SIGTERM, SIGINT 等
}
```

## 四、Gin 的优雅关闭实现

### 4.1 标准库的 Shutdown

```go
// Gin 使用标准库的 Shutdown 方法
func main() {
    router := gin.Default()
    router.GET("/", handler)
    
    srv := &http.Server{
        Addr:    ":8080",
        Handler: router,
    }
    
    // 启动服务器
    go func() {
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("listen: %s\n", err)
        }
    }()
    
    // 等待停止信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    log.Println("Shutting down server...")
    
    // 优雅关闭
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }
    
    log.Println("Server exiting")
}
```

### 4.2 Shutdown 的工作原理

```go
// net/http/server.go
func (srv *Server) Shutdown(ctx context.Context) error {
    // 1. 关闭监听器（不再接受新连接）
    srv.closeListenersLocked()
    
    // 2. 等待现有连接关闭
    // 3. 等待所有请求处理完成
    // 4. 超时后强制关闭
    
    return nil
}
```

## 五、Fiber 的优雅关闭实现

### 5.1 Shutdown 方法

```go
// app.go
func (app *App) Shutdown() error {
    // 1. 关闭服务器（不再接受新连接）
    if app.server != nil {
        return app.server.Shutdown()
    }
    return nil
}

// 使用示例
func main() {
    app := fiber.New()
    app.Get("/", handler)
    
    // 启动服务器
    go func() {
        if err := app.Listen(":3000"); err != nil {
            log.Fatal(err)
        }
    }()
    
    // 等待停止信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, os.Interrupt)
    <-quit
    
    // 优雅关闭
    if err := app.Shutdown(); err != nil {
        log.Fatal(err)
    }
}
```

## 六、优雅关闭的实现技巧

### 6.1 使用 Context 超时

```go
// ✅ 好的方式：使用超时控制
func gracefulShutdown(server *http.Server, timeout time.Duration) error {
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()
    
    // 优雅关闭（最多等待 timeout 时间）
    return server.Shutdown(ctx)
}

// ❌ 不好的方式：无限等待
func gracefulShutdown(server *http.Server) error {
    // 可能永远等待
    return server.Shutdown(context.Background())
}
```

### 6.2 处理超时

```go
// ✅ 好的方式：处理超时情况
func gracefulShutdown(server *http.Server, timeout time.Duration) error {
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()
    
    if err := server.Shutdown(ctx); err != nil {
        if err == context.DeadlineExceeded {
            // 超时，强制关闭
            log.Warn("Shutdown timeout, forcing close")
            return server.Close()  // 强制关闭
        }
        return err
    }
    
    return nil
}
```

### 6.3 等待后台任务

```go
// ✅ 好的方式：等待后台任务完成
func gracefulShutdown(server *http.Server, wg *sync.WaitGroup, timeout time.Duration) error {
    // 1. 停止接受新请求
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()
    
    if err := server.Shutdown(ctx); err != nil {
        return err
    }
    
    // 2. 等待后台任务完成
    done := make(chan struct{})
    go func() {
        wg.Wait()  // 等待所有后台任务完成
        close(done)
    }()
    
    select {
    case <-done:
        return nil
    case <-time.After(timeout):
        return fmt.Errorf("timeout waiting for background tasks")
    }
}
```

## 七、优雅关闭的最佳实践

### 7.1 完整的优雅关闭示例

```go
func main() {
    // 1. 创建服务器
    srv := &http.Server{
        Addr:    ":8080",
        Handler: router,
    }
    
    // 2. 启动服务器
    go func() {
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("listen: %s\n", err)
        }
    }()
    
    // 3. 等待停止信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    // 4. 优雅关闭
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }
    
    // 5. 清理资源
    cleanup()
    
    log.Println("Server exited")
}
```

### 7.2 资源清理

```go
// ✅ 好的方式：在关闭时清理资源
func cleanup() {
    // 1. 关闭数据库连接
    if db != nil {
        db.Close()
    }
    
    // 2. 关闭 Redis 连接
    if redis != nil {
        redis.Close()
    }
    
    // 3. 关闭其他资源
    // ...
}
```

### 7.3 健康检查

```go
// ✅ 好的方式：在关闭前检查健康状态
func gracefulShutdown(server *http.Server) error {
    // 1. 标记为关闭中（健康检查返回 503）
    isShuttingDown.Store(true)
    
    // 2. 等待一段时间，让负载均衡器发现
    time.Sleep(5 * time.Second)
    
    // 3. 优雅关闭
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    return server.Shutdown(ctx)
}
```

## 八、总结

### 8.1 优雅关闭的核心思想

1. **停止接受新请求**: 关闭监听器
2. **等待现有请求完成**: 使用 Shutdown 方法
3. **超时控制**: 避免无限等待
4. **资源清理**: 关闭数据库、Redis 等连接
5. **信号处理**: 监听 SIGTERM、SIGINT 等信号

### 8.2 各框架的优雅关闭特点

| 框架 | 特点 | 优势 |
|------|------|------|
| **Kratos** | 完整的生命周期管理 | 钩子函数、超时控制 |
| **GoFrame** | 支持优雅重启 | 零停机部署 |
| **Gin** | 使用标准库 | 简单直接 |
| **Fiber** | 基于 Fasthttp | 高性能 |

### 8.3 最佳实践

- ✅ **总是使用优雅关闭**: 避免中断正在处理的请求
- ✅ **设置合理的超时**: 避免无限等待
- ✅ **清理资源**: 关闭数据库、Redis 等连接
- ✅ **健康检查**: 在关闭前标记为不可用
- ✅ **日志记录**: 记录关闭过程，便于排查问题

优雅关闭是生产环境必备的功能，理解它有助于我们编写更可靠的服务！

