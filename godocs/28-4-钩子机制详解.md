# 钩子机制详解

## 一、什么是钩子（Hook）？

### 1.1 钩子的概念

**钩子（Hook）** 是一种设计模式，允许在**特定时机**执行自定义代码，而不修改核心代码。

**类比**: 就像墙上的插座，可以在特定位置插入电器，而不需要修改墙的结构。

### 1.2 钩子的优势

1. **解耦**: 核心代码和扩展代码分离
2. **灵活**: 可以在多个时机插入代码
3. **可扩展**: 可以添加多个钩子函数
4. **不侵入**: 不需要修改核心代码

## 二、GoFrame 的钩子机制

### 2.1 钩子类型

```go
// net/ghttp/ghttp_hook.go
type HookName string

const (
    HookBeforeServe  HookName = "BeforeServe"  // 服务请求前
    HookAfterServe   HookName = "AfterServe"   // 服务请求后
    HookBeforeOutput HookName = "BeforeOutput"  // 输出响应前
    HookAfterOutput  HookName = "AfterOutput"   // 输出响应后
)
```

### 2.2 钩子注册

```go
// 注册钩子
func (s *Server) BindHookHandler(pattern string, hookName HookName, handler HandlerFunc) {
    // 注册钩子处理器
}

// 使用示例
s.BindHookHandler("/*", ghttp.HookBeforeServe, func(r *ghttp.Request) {
    // 在服务请求前执行
    log.Printf("Request: %s %s", r.Method, r.URL.Path)
})

s.BindHookHandler("/*", ghttp.HookAfterServe, func(r *ghttp.Request) {
    // 在服务请求后执行
    log.Printf("Response: %d", r.Response.Status)
})
```

### 2.3 钩子执行时机

```go
// 请求处理流程
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    request := s.newRequest(w, r)
    
    // 1. BeforeServe 钩子
    s.callHookHandler(request, HookBeforeServe)
    
    // 2. 执行中间件和路由处理器
    s.handleRequest(request)
    
    // 3. AfterServe 钩子
    s.callHookHandler(request, HookAfterServe)
    
    // 4. BeforeOutput 钩子
    s.callHookHandler(request, HookBeforeOutput)
    
    // 5. 输出响应
    request.Response.Output()
    
    // 6. AfterOutput 钩子
    s.callHookHandler(request, HookAfterOutput)
}
```

### 2.4 使用示例

```go
// 1. 请求日志钩子
s.BindHookHandler("/*", ghttp.HookBeforeServe, func(r *ghttp.Request) {
    startTime := time.Now()
    r.SetCtxVar("startTime", startTime)
})

s.BindHookHandler("/*", ghttp.HookAfterServe, func(r *ghttp.Request) {
    startTime := r.GetCtxVar("startTime").(time.Time)
    duration := time.Since(startTime)
    log.Printf("Request %s %s took %v", r.Method, r.URL.Path, duration)
})

// 2. 响应修改钩子
s.BindHookHandler("/api/*", ghttp.HookBeforeOutput, func(r *ghttp.Request) {
    // 在输出前修改响应
    r.Response.Header().Set("X-Request-ID", generateRequestID())
})

// 3. 统计钩子
s.BindHookHandler("/*", ghttp.HookAfterOutput, func(r *ghttp.Request) {
    // 统计请求
    stats.Increment(r.Method, r.URL.Path, r.Response.Status)
})
```

## 三、Kratos 的钩子机制

### 3.1 生命周期钩子

```go
// app.go
type App struct {
    opts options
}

type options struct {
    // 生命周期钩子
    beforeStart []func(context.Context) error
    beforeStop  []func(context.Context) error
    afterStart  []func(context.Context) error
    afterStop   []func(context.Context) error
}

// 注册钩子
func BeforeStart(fn func(context.Context) error) Option {
    return func(o *options) {
        o.beforeStart = append(o.beforeStart, fn)
    }
}

func AfterStart(fn func(context.Context) error) Option {
    return func(o *options) {
        o.afterStart = append(o.afterStart, fn)
    }
}
```

### 3.2 钩子执行时机

```go
// app.go
func (a *App) Run() error {
    // 1. BeforeStart 钩子
    for _, fn := range a.opts.beforeStart {
        if err = fn(sctx); err != nil {
            return err
        }
    }
    
    // 2. 启动服务器
    // ...
    
    // 3. AfterStart 钩子
    for _, fn := range a.opts.afterStart {
        if err = fn(sctx); err != nil {
            return err
        }
    }
    
    // 4. 等待停止信号
    // ...
    
    // 5. BeforeStop 钩子
    for _, fn := range a.opts.beforeStop {
        err = fn(sctx)
    }
    
    // 6. 停止服务器
    // ...
    
    // 7. AfterStop 钩子
    for _, fn := range a.opts.afterStop {
        err = fn(sctx)
    }
    
    return err
}
```

### 3.3 使用示例

```go
app := kratos.New(
    // 启动前钩子
    kratos.BeforeStart(func(ctx context.Context) error {
        // 初始化数据库连接
        return initDatabase(ctx)
    }),
    
    kratos.BeforeStart(func(ctx context.Context) error {
        // 初始化缓存
        return initCache(ctx)
    }),
    
    // 启动后钩子
    kratos.AfterStart(func(ctx context.Context) error {
        // 启动后台任务
        go startBackgroundTasks(ctx)
        return nil
    }),
    
    // 停止前钩子
    kratos.BeforeStop(func(ctx context.Context) error {
        // 停止接受新请求
        return stopAcceptingRequests(ctx)
    }),
    
    // 停止后钩子
    kratos.AfterStop(func(ctx context.Context) error {
        // 清理资源
        return cleanup(ctx)
    }),
)
```

## 四、Fiber 的钩子机制

### 4.1 Hooks 接口

```go
// hooks.go
type Hooks struct {
    OnListen  []func(Listener) error
    OnShutdown []func() error
}

// 注册钩子
func (app *App) Hooks() *Hooks {
    return app.hooks
}

// 使用示例
app.Hooks().OnListen = append(app.Hooks().OnListen, func(ln net.Listener) error {
    log.Printf("Server listening on %s", ln.Addr())
    return nil
})

app.Hooks().OnShutdown = append(app.Hooks().OnShutdown, func() error {
    log.Println("Server shutting down")
    return nil
})
```

## 五、钩子机制的应用场景

### 5.1 请求日志

```go
// 使用钩子记录请求日志
s.BindHookHandler("/*", ghttp.HookBeforeServe, func(r *ghttp.Request) {
    log.Printf("[%s] %s %s", time.Now().Format("2006-01-02 15:04:05"), r.Method, r.URL.Path)
})
```

### 5.2 性能监控

```go
// 使用钩子监控性能
s.BindHookHandler("/*", ghttp.HookBeforeServe, func(r *ghttp.Request) {
    r.SetCtxVar("startTime", time.Now())
})

s.BindHookHandler("/*", ghttp.HookAfterServe, func(r *ghttp.Request) {
    startTime := r.GetCtxVar("startTime").(time.Time)
    duration := time.Since(startTime)
    metrics.RecordDuration(r.Method, r.URL.Path, duration)
})
```

### 5.3 响应修改

```go
// 使用钩子修改响应
s.BindHookHandler("/api/*", ghttp.HookBeforeOutput, func(r *ghttp.Request) {
    // 添加响应头
    r.Response.Header().Set("X-Request-ID", generateID())
    r.Response.Header().Set("X-Server-Version", "1.0.0")
})
```

### 5.4 资源初始化

```go
// 使用生命周期钩子初始化资源
app := kratos.New(
    kratos.BeforeStart(func(ctx context.Context) error {
        // 初始化数据库
        db, err := sql.Open("mysql", dsn)
        if err != nil {
            return err
        }
        // 存储到 context 或其他地方
        return nil
    }),
)
```

## 六、钩子机制的最佳实践

### 6.1 钩子应该轻量

```go
// ✅ 好的方式：钩子轻量，快速执行
s.BindHookHandler("/*", ghttp.HookBeforeServe, func(r *ghttp.Request) {
    // 快速操作
    r.SetCtxVar("startTime", time.Now())
})

// ❌ 不好的方式：钩子执行耗时操作
s.BindHookHandler("/*", ghttp.HookBeforeServe, func(r *ghttp.Request) {
    // 耗时操作，阻塞请求处理
    time.Sleep(1 * time.Second)
    // 或执行复杂的数据库查询
})
```

### 6.2 钩子应该幂等

```go
// ✅ 好的方式：钩子幂等
s.BindHookHandler("/*", ghttp.HookBeforeServe, func(r *ghttp.Request) {
    // 幂等操作：多次执行结果相同
    r.SetCtxVar("requestID", generateID())
})

// ❌ 不好的方式：钩子非幂等
var counter int
s.BindHookHandler("/*", ghttp.HookBeforeServe, func(r *ghttp.Request) {
    counter++  // 非幂等，每次执行结果不同
})
```

### 6.3 钩子应该处理错误

```go
// ✅ 好的方式：钩子处理错误
s.BindHookHandler("/*", ghttp.HookBeforeServe, func(r *ghttp.Request) {
    if err := doSomething(); err != nil {
        // 记录错误，但不中断请求处理
        log.Error(err)
    }
})

// ❌ 不好的方式：钩子忽略错误
s.BindHookHandler("/*", ghttp.HookBeforeServe, func(r *ghttp.Request) {
    doSomething()  // 忽略错误，可能导致问题
})
```

## 七、总结

### 7.1 钩子机制的核心思想

1. **特定时机**: 在特定时机执行自定义代码
2. **解耦设计**: 核心代码和扩展代码分离
3. **可扩展性**: 可以添加多个钩子函数
4. **不侵入**: 不需要修改核心代码

### 7.2 各框架的钩子机制

| 框架 | 钩子类型 | 特点 |
|------|---------|------|
| **GoFrame** | 请求处理钩子 | BeforeServe、AfterServe 等 |
| **Kratos** | 生命周期钩子 | BeforeStart、AfterStart 等 |
| **Fiber** | 服务器钩子 | OnListen、OnShutdown |
| **Gin** | 中间件 | 通过中间件实现类似功能 |

### 7.3 最佳实践

- ✅ **钩子应该轻量**: 避免阻塞请求处理
- ✅ **钩子应该幂等**: 多次执行结果相同
- ✅ **钩子应该处理错误**: 记录错误但不中断流程
- ✅ **合理使用钩子**: 不要过度使用，影响性能

钩子机制是框架扩展性的重要体现，理解它有助于我们更好地扩展框架功能！

