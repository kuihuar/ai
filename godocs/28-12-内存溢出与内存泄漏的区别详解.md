# 内存溢出与内存泄漏的区别详解

## 一、核心区别

### 1.1 定义

**内存溢出（OOM - Out of Memory）**:
- **定义**: 程序在运行过程中，申请的内存超过了系统能够提供的内存空间
- **特点**: 通常是**短时间内大量分配内存**导致的
- **结果**: 系统会杀死进程（OOM Killer）

**内存泄漏（Memory Leak）**:
- **定义**: 程序在运行过程中，分配的内存没有被正确释放，导致内存无法被回收
- **特点**: **随着时间的推移，内存使用量逐渐增加**
- **结果**: 最终可能导致内存溢出

### 1.2 关键区别

| 特性 | 内存溢出（OOM） | 内存泄漏（Memory Leak） |
|------|----------------|----------------------|
| **发生速度** | 快速（几秒到几分钟） | 缓慢（几小时到几天） |
| **内存增长** | 突然大量增长 | 逐渐增长 |
| **原因** | 一次性分配过多内存 | 内存没有释放，累积 |
| **可恢复性** | 通常不可恢复（进程被杀死） | 可以修复（释放内存） |
| **检测** | 容易检测（进程崩溃） | 难以检测（需要监控） |

## 二、内存溢出（OOM）详解

### 2.1 什么是内存溢出？

**内存溢出**是指程序在运行过程中，申请的内存超过了系统能够提供的内存空间。

```go
// ❌ 内存溢出示例
func oomExample() {
    // 一次性分配大量内存
    data := make([]byte, 10*1024*1024*1024)  // 10GB
    _ = data
    // 如果系统内存不足，会导致 OOM
}
```

### 2.2 内存溢出的特点

#### 1. 快速发生

```go
// 短时间内大量分配内存
func quickOOM() {
    for i := 0; i < 1000; i++ {
        // 每次分配 100MB
        data := make([]byte, 100*1024*1024)
        _ = data
        // 如果系统内存只有 1GB，很快就会 OOM
    }
}
```

#### 2. 系统会杀死进程

```go
// 当内存不足时，系统会杀死进程
func main() {
    // 分配大量内存
    data := make([]byte, 100*1024*1024*1024)  // 100GB
    _ = data
    // 系统内存不足，OOM Killer 会杀死进程
    // 退出码通常是 137（128 + 9，9 是 SIGKILL）
}
```

#### 3. 错误信息

```
fatal error: runtime: out of memory
runtime: cannot allocate memory
```

### 2.3 内存溢出的常见场景

#### 场景 1: 一次性分配大量内存

```go
// ❌ 一次性分配过多内存
func loadLargeFile() {
    // 尝试将整个大文件加载到内存
    data, err := os.ReadFile("huge_file.txt")  // 文件 10GB
    if err != nil {
        log.Fatal(err)
    }
    // 如果系统内存不足，会导致 OOM
    _ = data
}
```

#### 场景 2: 无限分配内存

```go
// ❌ 无限分配内存
func infiniteAllocation() {
    var data [][]byte
    for {
        // 不断分配内存
        chunk := make([]byte, 100*1024*1024)  // 100MB
        data = append(data, chunk)
        // 最终会导致 OOM
    }
}
```

#### 场景 3: 递归导致栈溢出（也是一种内存溢出）

```go
// ❌ 递归过深导致栈溢出
func recursive(n int) {
    if n == 0 {
        return
    }
    var data [1024]byte  // 局部变量占用栈空间
    _ = data
    recursive(n - 1)  // 递归调用
}

func main() {
    recursive(1000000)  // 栈溢出
}
```

### 2.4 内存溢出的解决方案

#### 1. 分批处理大数据

```go
// ✅ 分批处理，避免一次性加载所有数据
func processLargeFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()
    
    // 使用缓冲区，分批读取
    buffer := make([]byte, 1024*1024)  // 1MB 缓冲区
    for {
        n, err := file.Read(buffer)
        if err == io.EOF {
            break
        }
        if err != nil {
            return err
        }
        // 处理数据
        processChunk(buffer[:n])
    }
    return nil
}
```

#### 2. 使用流式处理

```go
// ✅ 流式处理，不将所有数据加载到内存
func streamProcess(reader io.Reader) error {
    scanner := bufio.NewScanner(reader)
    for scanner.Scan() {
        line := scanner.Text()
        // 逐行处理，不占用大量内存
        processLine(line)
    }
    return scanner.Err()
}
```

#### 3. 设置内存限制

```go
// ✅ 限制内存使用
func limitedAllocation() {
    maxSize := 100 * 1024 * 1024  // 100MB 限制
    var totalSize int
    
    for i := 0; i < 1000; i++ {
        size := 10 * 1024 * 1024  // 10MB
        if totalSize + size > maxSize {
            // 超过限制，停止分配
            break
        }
        data := make([]byte, size)
        _ = data
        totalSize += size
    }
}
```

## 三、内存泄漏（Memory Leak）详解

### 3.1 什么是内存泄漏？

**内存泄漏**是指程序在运行过程中，分配的内存没有被正确释放，导致内存无法被回收。

```go
// ❌ 内存泄漏示例
var globalData []byte

func leakMemory() {
    // 分配内存但没有释放
    data := make([]byte, 10*1024*1024)  // 10MB
    globalData = append(globalData, data...)
    // globalData 一直增长，内存无法被回收
}
```

### 3.2 内存泄漏的特点

#### 1. 缓慢发生

```go
// 内存逐渐增长
func slowLeak() {
    for {
        // 每次分配少量内存
        data := make([]byte, 1024*1024)  // 1MB
        globalSlice = append(globalSlice, data)
        time.Sleep(1 * time.Second)
        // 运行几小时后，内存使用量逐渐增加
    }
}
```

#### 2. 内存无法被回收

```go
// 内存被引用，无法被 GC 回收
var cache = make(map[string][]byte)

func leakCache() {
    for i := 0; i < 1000000; i++ {
        key := fmt.Sprintf("key-%d", i)
        data := make([]byte, 1024)  // 1KB
        cache[key] = data
        // cache 一直增长，内存无法被回收
    }
}
```

#### 3. 最终导致 OOM

```go
// 内存泄漏最终会导致 OOM
func leakToOOM() {
    for {
        // 不断泄漏内存
        leakMemory()
        // 运行几天后，内存耗尽，导致 OOM
    }
}
```

### 3.3 内存泄漏的常见场景

#### 场景 1: 全局变量累积

```go
// ❌ 全局变量累积导致内存泄漏
var globalSlice []byte

func leakGlobal() {
    for i := 0; i < 1000; i++ {
        data := make([]byte, 1024*1024)  // 1MB
        globalSlice = append(globalSlice, data...)
        // globalSlice 一直增长，内存无法被回收
    }
}
```

#### 场景 2: Map 或 Slice 不断增长

```go
// ❌ Map 不断增长导致内存泄漏
var cache = make(map[string][]byte)

func leakMap() {
    for i := 0; i < 1000000; i++ {
        key := fmt.Sprintf("key-%d", i)
        data := make([]byte, 1024)  // 1KB
        cache[key] = data
        // cache 一直增长，没有清理机制
    }
}
```

#### 场景 3: Goroutine 泄漏

```go
// ❌ Goroutine 泄漏导致内存泄漏
func leakGoroutine() {
    for i := 0; i < 1000; i++ {
        go func() {
            ch := make(chan int)
            <-ch  // 永远等待，goroutine 永远不会退出
            // goroutine 占用的内存无法被回收
        }()
    }
}
```

#### 场景 4: Channel 泄漏

```go
// ❌ Channel 泄漏导致内存泄漏
func leakChannel() {
    for i := 0; i < 1000; i++ {
        ch := make(chan int, 1000)
        go func() {
            ch <- 1  // 发送数据
            // 但没有接收者，channel 一直占用内存
        }()
    }
}
```

#### 场景 5: 文件或连接没有关闭

```go
// ❌ 文件没有关闭导致内存泄漏
func leakFile() {
    for i := 0; i < 1000; i++ {
        file, _ := os.Open("test.txt")
        // 没有关闭文件，文件描述符和缓冲区占用内存
        _ = file
    }
}
```

#### 场景 6: 定时器没有停止

```go
// ❌ 定时器没有停止导致内存泄漏
func leakTimer() {
    for i := 0; i < 1000; i++ {
        ticker := time.NewTicker(1 * time.Second)
        go func() {
            for range ticker.C {
                // 处理
            }
        }()
        // ticker 没有停止，一直占用内存
    }
}
```

### 3.4 内存泄漏的解决方案

#### 1. 及时释放资源

```go
// ✅ 使用 defer 确保资源被释放
func processFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()  // 确保文件被关闭
    
    // 处理文件
    return nil
}
```

#### 2. 限制缓存大小

```go
// ✅ 限制缓存大小，避免无限增长
type LRUCache struct {
    cache map[string]interface{}
    maxSize int
}

func (c *LRUCache) Set(key string, value interface{}) {
    if len(c.cache) >= c.maxSize {
        // 删除最旧的项
        c.evictOldest()
    }
    c.cache[key] = value
}
```

#### 3. 使用对象池

```go
// ✅ 使用对象池复用对象
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 1024)
    },
}

func getBuffer() []byte {
    return bufferPool.Get().([]byte)
}

func putBuffer(buf []byte) {
    bufferPool.Put(buf)
}
```

#### 4. 正确关闭 Goroutine

```go
// ✅ 使用 Context 控制 goroutine 生命周期
func controlledGoroutine(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return  // goroutine 正确退出
        default:
            // 工作
        }
    }
}
```

#### 5. 定期清理

```go
// ✅ 定期清理缓存
func cleanupCache() {
    ticker := time.NewTicker(1 * time.Hour)
    defer ticker.Stop()
    
    for range ticker.C {
        // 清理过期的缓存项
        cleanupExpired()
    }
}
```

## 四、实际对比示例

### 4.1 内存溢出示例

```go
// 内存溢出：快速发生，短时间内大量分配内存
func oomExample() {
    fmt.Println("开始分配内存...")
    
    // 一次性分配 10GB 内存
    data := make([]byte, 10*1024*1024*1024)
    _ = data
    
    fmt.Println("内存分配完成")
    // 如果系统内存不足，程序会立即崩溃
    // 错误：fatal error: runtime: out of memory
}

// 运行结果：
// 开始分配内存...
// fatal error: runtime: out of memory
// runtime: cannot allocate memory
// Process finished with exit code 2
```

**特点**:
- 快速发生（几秒内）
- 内存突然大量增长
- 程序立即崩溃

### 4.2 内存泄漏示例

```go
// 内存泄漏：缓慢发生，内存逐渐增长
var globalData []byte

func leakExample() {
    fmt.Println("开始泄漏内存...")
    
    for i := 0; i < 1000; i++ {
        // 每次分配 1MB，但不释放
        data := make([]byte, 1024*1024)
        globalData = append(globalData, data...)
        time.Sleep(100 * time.Millisecond)
    }
    
    fmt.Println("内存泄漏完成")
    // 程序继续运行，但内存无法被回收
}

// 运行结果：
// 开始泄漏内存...
// 内存泄漏完成
// 程序继续运行，但内存使用量增加了 1GB
```

**特点**:
- 缓慢发生（几小时到几天）
- 内存逐渐增长
- 程序继续运行，但内存无法被回收

### 4.3 内存泄漏最终导致 OOM

```go
// 内存泄漏最终导致 OOM
var globalData []byte

func leakToOOM() {
    for {
        // 不断泄漏内存
        data := make([]byte, 10*1024*1024)  // 10MB
        globalData = append(globalData, data...)
        time.Sleep(1 * time.Second)
        
        // 运行几天后，内存耗尽，导致 OOM
        // 系统会杀死进程（退出码 137）
    }
}
```

## 五、检测和诊断

### 5.1 检测内存溢出

```go
// 内存溢出通常会导致程序立即崩溃
// 错误信息：fatal error: runtime: out of memory
```

### 5.2 检测内存泄漏

#### 1. 使用 pprof 分析内存

```go
// 添加 pprof 端点
import _ "net/http/pprof"

func main() {
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    // ...
}

// 使用工具分析
// go tool pprof http://localhost:6060/debug/pprof/heap
```

#### 2. 监控内存使用

```go
// ✅ 监控内存使用
func monitorMemory() {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        
        fmt.Printf("Alloc: %d KB, Sys: %d KB, NumGC: %d\n",
            m.Alloc/1024,
            m.Sys/1024,
            m.NumGC,
        )
        
        // 如果内存持续增长，可能是内存泄漏
        if m.Alloc > 100*1024*1024 {  // 100MB
            fmt.Println("警告：内存使用过多")
        }
    }
}
```

#### 3. 使用 runtime.GC() 强制 GC

```go
// ✅ 强制 GC 来检测内存泄漏
func testMemoryLeak() {
    var m1, m2 runtime.MemStats
    
    runtime.GC()
    runtime.ReadMemStats(&m1)
    
    // 执行可能泄漏内存的操作
    leakMemory()
    
    runtime.GC()
    runtime.ReadMemStats(&m2)
    
    // 如果内存没有减少，可能是内存泄漏
    if m2.Alloc > m1.Alloc {
        fmt.Printf("可能的内存泄漏：%d bytes\n", m2.Alloc-m1.Alloc)
    }
}
```

## 六、最佳实践

### 6.1 预防内存溢出

1. **分批处理大数据**
   - 不要一次性加载所有数据
   - 使用流式处理

2. **设置内存限制**
   - 限制单次分配的内存大小
   - 使用对象池复用对象

3. **监控内存使用**
   - 定期检查内存使用量
   - 设置告警阈值

### 6.2 预防内存泄漏

1. **及时释放资源**
   - 使用 `defer` 确保资源被释放
   - 关闭文件、连接、定时器等

2. **限制缓存大小**
   - 使用 LRU 缓存
   - 定期清理过期数据

3. **正确管理 Goroutine**
   - 使用 Context 控制生命周期
   - 使用 WaitGroup 等待完成

4. **使用对象池**
   - 复用对象，减少分配
   - 使用 `sync.Pool`

5. **定期监控**
   - 使用 pprof 分析内存
   - 监控内存使用趋势

## 七、总结

### 7.1 核心区别

| 特性 | 内存溢出（OOM） | 内存泄漏（Memory Leak） |
|------|----------------|----------------------|
| **发生速度** | 快速（几秒到几分钟） | 缓慢（几小时到几天） |
| **内存增长** | 突然大量增长 | 逐渐增长 |
| **原因** | 一次性分配过多内存 | 内存没有释放，累积 |
| **可恢复性** | 通常不可恢复（进程被杀死） | 可以修复（释放内存） |
| **检测** | 容易检测（进程崩溃） | 难以检测（需要监控） |
| **解决方案** | 分批处理、限制大小 | 及时释放、限制缓存 |

### 7.2 关键要点

- ✅ **内存溢出**是短时间内大量分配内存导致的
- ✅ **内存泄漏**是内存没有释放，逐渐累积导致的
- ✅ **内存泄漏最终可能导致内存溢出**
- ✅ **预防内存溢出**：分批处理、设置限制
- ✅ **预防内存泄漏**：及时释放、限制缓存、正确管理资源

### 7.3 检测工具

- **内存溢出**：程序崩溃，错误信息明显
- **内存泄漏**：使用 `pprof`、监控内存使用趋势

记住这些区别和最佳实践，可以编写更健壮、更高效的 Go 程序！

