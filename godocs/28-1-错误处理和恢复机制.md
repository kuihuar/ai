# 错误处理和恢复机制详解

## 一、为什么需要错误恢复？

### 1.1 Panic 的问题

在 Go 语言中，如果发生 **panic** 且没有被恢复，整个程序会崩溃：

```go
// ❌ 没有错误恢复
func handler(w http.ResponseWriter, r *http.Request) {
    // 如果这里发生 panic，整个服务器会崩溃
    data := make([]int, -1)  // panic: negative length
    // ...
}
```

**问题**:
- 一个请求的 panic 会导致整个服务器崩溃（因为每个请求在独立的 goroutine 中处理，未恢复的 panic 会导致整个程序崩溃）
- 所有正在处理的请求都会中断
- 服务不可用

> **注意**: 虽然每个 HTTP 请求在独立的 goroutine 中处理，但 Go 语言的设计是：**任何 goroutine 的未恢复 panic 都会导致整个程序崩溃**。这就是为什么必须使用 Recovery 中间件的原因。详见 `28-8-Go中Panic与协程的关系详解.md`

### 1.2 错误恢复的重要性

```go
// ✅ 有错误恢复
func handler(w http.ResponseWriter, r *http.Request) {
    defer func() {
        if err := recover(); err != nil {
            // 恢复 panic，返回错误响应
            http.Error(w, "Internal Server Error", 500)
        }
    }()
    
    // 即使发生 panic，也不会导致服务器崩溃
    data := make([]int, -1)  // panic 被捕获
}
```

**优势**:
- 单个请求的 panic 不会影响其他请求
- 服务器保持运行
- 可以返回友好的错误响应

## 二、Gin 的错误恢复机制

### 2.1 Recovery 中间件

```go
// recovery.go
func Recovery() HandlerFunc {
    return RecoveryWithWriter(DefaultErrorWriter)
}

func RecoveryWithWriter(out io.Writer, recovery ...RecoveryFunc) HandlerFunc {
    var logger *log.Logger
    if out != nil {
        logger = log.New(out, "\n\n\x1b[31m", log.LstdFlags)
    }
    
    return func(c *Context) {
        defer func() {
            if err := recover(); err != nil {
                // 1. 检查是否是连接断开错误
                var brokenPipe bool
                if ne, ok := err.(*net.OpError); ok {
                    var se *os.SyscallError
                    if errors.As(ne, &se) {
                        seStr := strings.ToLower(se.Error())
                        if strings.Contains(seStr, "broken pipe") ||
                           strings.Contains(seStr, "connection reset by peer") {
                            brokenPipe = true
                        }
                    }
                }
                
                // 2. 记录错误日志
                if logger != nil {
                    if brokenPipe {
                        // 连接断开，只记录简单日志
                        logger.Printf("%s\n%s%s", err, secureRequestDump(c.Request), reset)
                    } else if IsDebugging() {
                        // 调试模式，记录详细堆栈
                        logger.Printf("[Recovery] %s panic recovered:\n%s\n%s\n%s%s",
                            timeFormat(time.Now()), 
                            secureRequestDump(c.Request), 
                            err, 
                            stack(stackSkip), 
                            reset)
                    } else {
                        // 生产模式，记录简化堆栈
                        logger.Printf("[Recovery] %s panic recovered:\n%s\n%s%s",
                            timeFormat(time.Now()), 
                            err, 
                            stack(stackSkip), 
                            reset)
                    }
                }
                
                // 3. 处理错误
                if brokenPipe {
                    // 连接已断开，无法写入响应
                    c.Error(err.(error))
                    c.Abort()
                } else {
                    // 调用自定义恢复函数
                    handle(c, err)
                }
            }
        }()
        c.Next()
    }
}
```

### 2.2 堆栈跟踪

```go
// recovery.go
func stack(skip int) []byte {
    buf := new(bytes.Buffer)
    
    for i := skip; ; i++ {
        // 获取调用栈信息
        pc, file, line, ok := runtime.Caller(i)
        if !ok {
            break
        }
        
        // 打印文件位置
        fmt.Fprintf(buf, "%s:%d (0x%x)\n", file, line, pc)
        
        // 读取源代码行
        if file != lastFile {
            nLine, err := readNthLine(file, line-1)
            if err != nil {
                continue
            }
            lastFile = file
        }
        
        // 打印函数名和源代码
        fmt.Fprintf(buf, "\t%s: %s\n", function(pc), cmp.Or(nLine, dunno))
    }
    
    return buf.Bytes()
}
```

### 2.3 使用示例

```go
// 使用 Recovery 中间件
r := gin.Default()  // 默认包含 Recovery 中间件

// 或自定义 Recovery
r := gin.New()
r.Use(gin.CustomRecovery(func(c *gin.Context, err interface{}) {
    // 自定义错误处理
    c.JSON(500, gin.H{
        "error": "Internal Server Error",
        "message": fmt.Sprintf("%v", err),
    })
}))

// 即使 handler 发生 panic，也不会导致服务器崩溃
r.GET("/panic", func(c *gin.Context) {
    panic("something went wrong")  // 会被 Recovery 捕获
})
```

## 三、Fiber 的错误恢复机制

### 3.1 Recovery 中间件

```go
// middleware/recover/recover.go
func New(config ...Config) fiber.Handler {
    cfg := configDefault(config...)
    
    return func(c fiber.Ctx) (err error) {
        // 检查是否需要跳过
        if cfg.Next != nil && cfg.Next(c) {
            return c.Next()
        }
        
        // 捕获 panic
        defer func() {
            if r := recover(); r != nil {
                // 1. 记录堆栈跟踪
                if cfg.EnableStackTrace {
                    cfg.StackTraceHandler(c, r)
                }
                
                // 2. 转换为 error
                var ok bool
                if err, ok = r.(error); !ok {
                    err = fmt.Errorf("%v", r)
                }
            }
        }()
        
        // 继续执行下一个处理器
        return c.Next()
    }
}
```

### 3.2 错误处理函数

```go
// app.go
type ErrorHandler = func(Ctx, error) error

// 默认错误处理
func DefaultErrorHandler(c Ctx, err error) error {
    code := StatusInternalServerError
    if e, ok := err.(*Error); ok {
        code = e.Code
    }
    return c.Status(code).SendString(err.Error())
}

// 使用
app := fiber.New(fiber.Config{
    ErrorHandler: func(c fiber.Ctx, err error) error {
        // 自定义错误处理
        return c.Status(500).JSON(fiber.Map{
            "error": err.Error(),
        })
    },
})
```

### 3.3 使用示例

```go
// 使用 Recovery 中间件
app := fiber.New()
app.Use(recover.New())

// 或自定义配置
app.Use(recover.New(recover.Config{
    EnableStackTrace: true,
    StackTraceHandler: func(c fiber.Ctx, e interface{}) {
        fmt.Printf("panic: %v\n%s\n", e, debug.Stack())
    },
}))

// 即使 handler 发生 panic，也不会导致服务器崩溃
app.Get("/panic", func(c fiber.Ctx) error {
    panic("something went wrong")  // 会被 Recovery 捕获
    return nil
})
```

## 四、Kratos 的错误恢复机制

### 4.1 Recovery 中间件

```go
// middleware/recovery/recovery.go
func Recovery(opts ...Option) middleware.Middleware {
    op := options{
        handler: func(context.Context, any, any) error {
            return ErrUnknownRequest
        },
    }
    for _, o := range opts {
        o(&op)
    }
    
    return func(handler middleware.Handler) middleware.Handler {
        return func(ctx context.Context, req any) (reply any, err error) {
            startTime := time.Now()
            defer func() {
                if rerr := recover(); rerr != nil {
                    // 1. 获取堆栈跟踪
                    buf := make([]byte, 64<<10)
                    n := runtime.Stack(buf, false)
                    buf = buf[:n]
                    
                    // 2. 记录错误日志
                    log.Context(ctx).Errorf("%v: %+v\n%s\n", rerr, req, buf)
                    
                    // 3. 设置延迟信息
                    ctx = context.WithValue(ctx, Latency{}, time.Since(startTime).Seconds())
                    
                    // 4. 调用自定义处理函数
                    err = op.handler(ctx, req, rerr)
                }
            }()
            return handler(ctx, req)
        }
    }
}
```

### 4.2 使用示例

```go
// 使用 Recovery 中间件
httpSrv := http.NewServer(
    http.Address(":8000"),
    http.Middleware(
        recovery.Recovery(
            recovery.WithHandler(func(ctx context.Context, req, err interface{}) error {
                // 自定义错误处理
                return errors.InternalServer("INTERNAL_ERROR", "internal server error")
            }),
        ),
    ),
)
```

## 五、GoFrame 的错误恢复机制

### 5.1 内置错误恢复

GoFrame 在服务器层面内置了错误恢复：

```go
// net/ghttp/ghttp_server.go
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // 内置错误恢复
    defer func() {
        if err := recover(); err != nil {
            s.handlePanic(w, r, err)
        }
    }()
    
    // 处理请求
    // ...
}
```

### 5.2 错误处理

```go
// 错误处理
func (s *Server) handlePanic(w http.ResponseWriter, r *http.Request, err interface{}) {
    // 记录错误日志
    s.Logger().Error(r.Context(), "panic recovered: %+v", err)
    
    // 返回错误响应
    w.WriteHeader(500)
    w.Write([]byte("Internal Server Error"))
}
```

## 六、错误恢复的最佳实践

### 6.1 区分错误类型

```go
// ✅ 好的方式：区分不同类型的错误
defer func() {
    if err := recover(); err != nil {
        switch e := err.(type) {
        case *MyCustomError:
            // 自定义错误，返回友好消息
            c.JSON(400, gin.H{"error": e.Message})
        case error:
            // 标准错误，记录日志
            log.Error(e)
            c.JSON(500, gin.H{"error": "Internal Server Error"})
        default:
            // 其他类型，记录详细日志
            log.Errorf("panic: %v", err)
            c.JSON(500, gin.H{"error": "Internal Server Error"})
        }
    }
}()
```

### 6.2 记录详细日志

```go
// ✅ 好的方式：记录详细的错误信息
defer func() {
    if err := recover(); err != nil {
        // 记录堆栈跟踪
        buf := make([]byte, 64<<10)
        n := runtime.Stack(buf, false)
        stack := buf[:n]
        
        // 记录请求信息
        log.Errorf("panic recovered: %v\nRequest: %s %s\nStack:\n%s",
            err,
            r.Method,
            r.URL.Path,
            stack,
        )
        
        // 返回错误响应
        c.JSON(500, gin.H{"error": "Internal Server Error"})
    }
}()
```

### 6.3 避免敏感信息泄露

```go
// ✅ 好的方式：避免泄露敏感信息
func secureRequestDump(r *http.Request) string {
    httpRequest, _ := httputil.DumpRequest(r, false)
    lines := strings.Split(string(httpRequest), "\r\n")
    
    // 隐藏敏感头部
    for i, line := range lines {
        if strings.HasPrefix(line, "Authorization:") {
            lines[i] = "Authorization: *"  // 隐藏认证信息
        }
        if strings.HasPrefix(line, "Cookie:") {
            lines[i] = "Cookie: *"  // 隐藏 Cookie
        }
    }
    
    return strings.Join(lines, "\r\n")
}
```

## 七、错误恢复的性能影响

### 7.1 性能开销

```go
// 错误恢复的性能开销很小
defer func() {
    if err := recover(); err != nil {
        // 只有在发生 panic 时才有开销
        // 正常情况下的开销可以忽略不计
    }
}()
```

**开销**:
- 正常情况：几乎为 0（只是检查标志位）
- Panic 情况：需要捕获堆栈，有一定开销

### 7.2 性能优化

```go
// ✅ 优化：只在需要时记录堆栈
defer func() {
    if err := recover(); err != nil {
        if isDebugMode {
            // 调试模式：记录详细堆栈
            buf := make([]byte, 64<<10)
            n := runtime.Stack(buf, false)
            log.Error(string(buf[:n]))
        } else {
            // 生产模式：只记录错误信息
            log.Error(err)
        }
    }
}()
```

## 八、总结

### 8.1 错误恢复的核心思想

1. **捕获 Panic**: 使用 `defer recover()` 捕获 panic
2. **记录日志**: 记录详细的错误信息和堆栈跟踪
3. **返回响应**: 返回友好的错误响应，而不是崩溃
4. **区分错误**: 根据错误类型采取不同的处理策略

### 8.2 各框架的错误恢复特点

| 框架 | 特点 | 优势 |
|------|------|------|
| **Gin** | 详细的堆栈跟踪 | 调试友好 |
| **Fiber** | 灵活的配置 | 易于自定义 |
| **Kratos** | 统一的错误处理 | 类型安全 |
| **GoFrame** | 内置错误恢复 | 开箱即用 |

### 8.3 最佳实践

- ✅ **总是使用 Recovery 中间件**: 防止服务器崩溃
- ✅ **记录详细日志**: 便于调试和排查问题
- ✅ **避免敏感信息泄露**: 保护用户隐私
- ✅ **区分错误类型**: 提供更友好的错误响应
- ✅ **性能优化**: 在生产环境简化日志记录

错误恢复是 Web 框架的必备功能，理解它有助于我们编写更健壮的应用程序！

