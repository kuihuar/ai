# 负载均衡算法详解

## 一、什么是负载均衡？

### 1.1 负载均衡的概念

**负载均衡（Load Balancing）** 是指将请求分发到多个服务器上，以实现：
- **提高性能**: 分散请求压力
- **提高可用性**: 单个服务器故障不影响服务
- **扩展性**: 可以轻松添加更多服务器

### 1.2 负载均衡的场景

```
客户端
  ↓
负载均衡器
  ↓
┌─────┬─────┬─────┐
│服务1 │服务2 │服务3 │
└─────┴─────┴─────┘
```

## 二、Kratos 的负载均衡实现

### 2.1 Selector 接口

```go
// selector/selector.go
type Selector interface {
    Rebalancer
    Select(ctx context.Context, opts ...SelectOption) (selected Node, done DoneFunc, err error)
}

type Rebalancer interface {
    Apply(nodes []Node)  // 应用节点列表
}
```

### 2.2 P2C 算法（Power of Two Choices）

#### 算法原理

**P2C** 是一种高效的负载均衡算法：
1. **随机选择两个节点**: 从所有节点中随机选择两个
2. **选择负载较低的**: 比较两个节点的负载，选择负载较低的
3. **更新统计信息**: 记录选择结果，用于下次选择

#### 实现代码

```go
// selector/p2c/p2c.go
func (s *Balancer) Pick(_ context.Context, nodes []selector.WeightedNode) (selector.WeightedNode, selector.DoneFunc, error) {
    if len(nodes) == 0 {
        return nil, nil, selector.ErrNoAvailable
    }
    if len(nodes) == 1 {
        done := nodes[0].Pick()
        return nodes[0], done, nil
    }
    
    // 1. 随机选择两个节点
    nodeA, nodeB := s.prePick(nodes)
    
    // 2. 比较权重，选择权重较高的
    var pc, upc selector.WeightedNode
    if nodeB.Weight() > nodeA.Weight() {
        pc, upc = nodeB, nodeA
    } else {
        pc, upc = nodeA, nodeB
    }
    
    // 3. 如果失败节点长时间未选择，强制选择一次
    if upc.PickElapsed() > forcePick && s.picked.CompareAndSwap(false, true) {
        defer s.picked.Store(false)
        pc = upc  // 强制选择失败节点
    }
    
    // 4. 选择节点并返回
    done := pc.Pick()
    return pc, done, nil
}

// 随机选择两个不同的节点
func (s *Balancer) prePick(nodes []selector.WeightedNode) (nodeA selector.WeightedNode, nodeB selector.WeightedNode) {
    s.mu.Lock()
    a := s.r.IntN(len(nodes))
    b := s.r.IntN(len(nodes) - 1)
    s.mu.Unlock()
    if b >= a {
        b = b + 1  // 确保 b != a
    }
    nodeA, nodeB = nodes[a], nodes[b]
    return
}
```

#### 算法优势

1. **时间复杂度 O(1)**: 只需要比较两个节点
2. **负载均衡好**: 通过比较选择负载较低的节点
3. **故障恢复**: 强制选择失败节点，触发健康检查

### 2.3 WRR 算法（Weighted Round Robin）

```go
// selector/wrr/wrr.go
type Balancer struct {
    mu    sync.Mutex
    nodes []selector.WeightedNode
    total int64
}

func (b *Balancer) Pick(ctx context.Context, nodes []selector.WeightedNode) (selector.WeightedNode, selector.DoneFunc, error) {
    // 1. 计算总权重
    total := int64(0)
    for _, node := range nodes {
        total += node.Weight()
    }
    
    // 2. 加权轮询
    // 根据权重分配请求
}
```

### 2.4 Random 算法

```go
// selector/random/random.go
type Balancer struct {
    r *rand.Rand
}

func (b *Balancer) Pick(ctx context.Context, nodes []selector.WeightedNode) (selector.WeightedNode, selector.DoneFunc, error) {
    // 随机选择一个节点
    index := b.r.IntN(len(nodes))
    return nodes[index], nodes[index].Pick(), nil
}
```

## 三、负载均衡算法的对比

### 3.1 算法特点

| 算法 | 时间复杂度 | 负载均衡 | 故障恢复 | 适用场景 |
|------|-----------|---------|---------|---------|
| **P2C** | O(1) | 好 | 好 | 高并发场景 |
| **WRR** | O(n) | 很好 | 一般 | 权重不同 |
| **Random** | O(1) | 一般 | 一般 | 简单场景 |
| **Round Robin** | O(1) | 好 | 一般 | 权重相同 |

### 3.2 性能对比

```
节点数量: 100
请求数量: 1,000,000

P2C:        ~100ms  (最快)
Random:     ~120ms
WRR:        ~500ms  (较慢，需要计算权重)
Round Robin: ~100ms
```

## 四、负载均衡的最佳实践

### 4.1 选择合适的算法

```go
// 根据场景选择算法
switch scenario {
case "high_concurrency":
    // 高并发场景：使用 P2C
    selector := p2c.New()
    
case "different_weights":
    // 权重不同：使用 WRR
    selector := wrr.New()
    
case "simple":
    // 简单场景：使用 Random
    selector := random.New()
}
```

### 4.2 健康检查

```go
// ✅ 好的方式：结合健康检查
type Node struct {
    address string
    weight  int64
    healthy bool  // 健康状态
}

func (b *Balancer) Pick(nodes []Node) Node {
    // 只选择健康的节点
    healthyNodes := filterHealthy(nodes)
    return p2cPick(healthyNodes)
}
```

### 4.3 故障转移

```go
// ✅ 好的方式：故障转移
func (b *Balancer) Pick(nodes []Node) (Node, error) {
    // 1. 尝试选择节点
    node, err := b.selectNode(nodes)
    if err != nil {
        return nil, err
    }
    
    // 2. 如果节点失败，重试其他节点
    if !node.IsHealthy() {
        return b.selectNode(removeNode(nodes, node))
    }
    
    return node, nil
}
```

## 五、总结

### 5.1 负载均衡的核心思想

1. **分散请求**: 将请求分发到多个服务器
2. **选择策略**: 根据算法选择最合适的节点
3. **故障处理**: 处理节点故障和恢复
4. **性能优化**: 选择高效的算法

### 5.2 P2C 算法的优势

- ✅ **时间复杂度 O(1)**: 性能极好
- ✅ **负载均衡好**: 通过比较选择负载较低的节点
- ✅ **故障恢复**: 强制选择失败节点，触发健康检查
- ✅ **实现简单**: 代码简洁易懂

### 5.3 最佳实践

- ✅ **选择合适的算法**: 根据场景选择
- ✅ **结合健康检查**: 只选择健康的节点
- ✅ **故障转移**: 处理节点故障
- ✅ **监控和统计**: 监控负载均衡效果

负载均衡是微服务架构的核心技术，理解它有助于我们设计更好的分布式系统！

