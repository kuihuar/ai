# Go 集成测试最佳实践

## 一、集成测试基础

### 1.1 什么是集成测试？

**集成测试**是测试多个组件协同工作的测试，通常涉及：
- 数据库
- 外部服务（API、消息队列等）
- 文件系统
- 网络

**与单元测试的区别**:
- **单元测试**: 测试单个函数/方法，使用 Mock
- **集成测试**: 测试多个组件协同工作，使用真实依赖

### 1.2 集成测试文件命名

```go
// ✅ 使用 build tag 标记集成测试
// +build integration

package user

import "testing"

func TestUserIntegration(t *testing.T) {
    // 集成测试代码
}
```

**运行方式**:
```bash
# 运行集成测试
go test -tags=integration ./...

# 跳过集成测试（只运行单元测试）
go test ./...
```

## 二、数据库集成测试

### 2.1 使用测试数据库

```go
// ✅ 使用独立的测试数据库
package user_test

import (
    "database/sql"
    "testing"
    _ "github.com/go-sql-driver/mysql"
)

func setupTestDB(t *testing.T) *sql.DB {
    t.Helper()
    
    // 连接到测试数据库
    db, err := sql.Open("mysql", "user:password@tcp(localhost:3306)/test_db")
    if err != nil {
        t.Fatalf("failed to connect to test database: %v", err)
    }
    
    // 运行迁移
    runMigrations(t, db)
    
    return db
}

func teardownTestDB(t *testing.T, db *sql.DB) {
    t.Helper()
    
    // 清理测试数据
    db.Exec("DELETE FROM users")
    db.Close()
}

func TestUserIntegration(t *testing.T) {
    db := setupTestDB(t)
    defer teardownTestDB(t, db)
    
    // 测试代码
    user := &User{Name: "Test User"}
    err := CreateUser(db, user)
    if err != nil {
        t.Fatalf("CreateUser() error = %v", err)
    }
    
    got, err := GetUser(db, user.ID)
    if err != nil {
        t.Fatalf("GetUser() error = %v", err)
    }
    
    if got.Name != "Test User" {
        t.Errorf("GetUser() = %v, want Test User", got.Name)
    }
}
```

### 2.2 使用事务回滚

```go
// ✅ 使用事务回滚，避免污染数据库
func TestUserIntegration(t *testing.T) {
    db := setupTestDB(t)
    defer db.Close()
    
    // 开始事务
    tx, err := db.Begin()
    if err != nil {
        t.Fatalf("Begin() error = %v", err)
    }
    defer tx.Rollback()  // 测试结束后回滚
    
    // 在事务中测试
    user := &User{Name: "Test User"}
    err = CreateUser(tx, user)
    if err != nil {
        t.Fatalf("CreateUser() error = %v", err)
    }
    
    // 验证
    got, err := GetUser(tx, user.ID)
    if err != nil {
        t.Fatalf("GetUser() error = %v", err)
    }
    
    if got.Name != "Test User" {
        t.Errorf("GetUser() = %v, want Test User", got.Name)
    }
}
```

### 2.3 使用 Docker 容器

```go
// ✅ 使用 testcontainers-go 创建临时数据库
package user_test

import (
    "context"
    "testing"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/wait"
)

func setupTestDB(t *testing.T) *sql.DB {
    t.Helper()
    
    ctx := context.Background()
    
    // 启动 MySQL 容器
    req := testcontainers.ContainerRequest{
        Image:        "mysql:8.0",
        ExposedPorts: []string{"3306/tcp"},
        Env: map[string]string{
            "MYSQL_ROOT_PASSWORD": "password",
            "MYSQL_DATABASE":      "test_db",
        },
        WaitingFor: wait.ForLog("ready for connections"),
    }
    
    mysqlC, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: req,
        Started:         true,
    })
    if err != nil {
        t.Fatalf("failed to start container: %v", err)
    }
    
    // 获取连接信息
    host, _ := mysqlC.Host(ctx)
    port, _ := mysqlC.MappedPort(ctx, "3306")
    
    dsn := fmt.Sprintf("root:password@tcp(%s:%s)/test_db", host, port.Port())
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        t.Fatalf("failed to connect: %v", err)
    }
    
    // 清理函数
    t.Cleanup(func() {
        mysqlC.Terminate(ctx)
    })
    
    return db
}
```

## 三、HTTP 集成测试

### 3.1 使用 httptest

```go
// ✅ 使用 httptest 测试 HTTP 处理函数
package handler_test

import (
    "net/http"
    "net/http/httptest"
    "testing"
)

func TestUserHandler(t *testing.T) {
    // 创建测试服务器
    handler := http.HandlerFunc(UserHandler)
    
    // 创建测试请求
    req := httptest.NewRequest("GET", "/user/1", nil)
    w := httptest.NewRecorder()
    
    // 执行请求
    handler.ServeHTTP(w, req)
    
    // 验证响应
    if w.Code != http.StatusOK {
        t.Errorf("handler returned status %d, want %d", w.Code, http.StatusOK)
    }
    
    // 验证响应体
    expected := `{"id":1,"name":"Test User"}`
    if w.Body.String() != expected {
        t.Errorf("handler returned body %s, want %s", w.Body.String(), expected)
    }
}
```

### 3.2 测试中间件

```go
// ✅ 测试中间件
func TestAuthMiddleware(t *testing.T) {
    tests := []struct {
        name           string
        token          string
        expectedStatus int
    }{
        {
            name:           "valid token",
            token:          "valid-token",
            expectedStatus: http.StatusOK,
        },
        {
            name:           "invalid token",
            token:          "invalid-token",
            expectedStatus: http.StatusUnauthorized,
        },
        {
            name:           "no token",
            token:          "",
            expectedStatus: http.StatusUnauthorized,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            handler := AuthMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                w.WriteHeader(http.StatusOK)
            }))
            
            req := httptest.NewRequest("GET", "/", nil)
            if tt.token != "" {
                req.Header.Set("Authorization", "Bearer "+tt.token)
            }
            
            w := httptest.NewRecorder()
            handler.ServeHTTP(w, req)
            
            if w.Code != tt.expectedStatus {
                t.Errorf("handler returned status %d, want %d", w.Code, tt.expectedStatus)
            }
        })
    }
}
```

### 3.3 测试完整 HTTP 服务器

```go
// ✅ 测试完整的 HTTP 服务器
func TestServerIntegration(t *testing.T) {
    // 启动测试服务器
    server := httptest.NewServer(setupRouter())
    defer server.Close()
    
    // 测试 API
    client := server.Client()
    
    // 创建用户
    resp, err := client.Post(server.URL+"/users", "application/json", 
        strings.NewReader(`{"name":"Test User"}`))
    if err != nil {
        t.Fatalf("POST /users error = %v", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusCreated {
        t.Errorf("POST /users status = %d, want %d", resp.StatusCode, http.StatusCreated)
    }
    
    // 获取用户
    resp, err = client.Get(server.URL + "/users/1")
    if err != nil {
        t.Fatalf("GET /users/1 error = %v", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        t.Errorf("GET /users/1 status = %d, want %d", resp.StatusCode, http.StatusOK)
    }
}
```

## 四、外部服务集成测试

### 4.1 使用 Mock 服务器

```go
// ✅ 使用 httptest 创建 Mock 服务器
func TestExternalAPIIntegration(t *testing.T) {
    // 创建 Mock 服务器
    mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if r.URL.Path == "/api/user" {
            w.WriteHeader(http.StatusOK)
            w.Write([]byte(`{"id":1,"name":"Test User"}`))
        } else {
            w.WriteHeader(http.StatusNotFound)
        }
    }))
    defer mockServer.Close()
    
    // 使用 Mock 服务器进行测试
    client := NewAPIClient(mockServer.URL)
    user, err := client.GetUser(1)
    if err != nil {
        t.Fatalf("GetUser() error = %v", err)
    }
    
    if user.Name != "Test User" {
        t.Errorf("GetUser() = %v, want Test User", user.Name)
    }
}
```

### 4.2 使用 Docker Compose

```yaml
# docker-compose.test.yml
version: '3.8'
services:
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: test_db
    ports:
      - "3306:3306"
  
  redis:
    image: redis:7
    ports:
      - "6379:6379"
```

```go
// ✅ 在测试中使用 Docker Compose
func TestIntegration(t *testing.T) {
    // 启动 Docker Compose
    cmd := exec.Command("docker-compose", "-f", "docker-compose.test.yml", "up", "-d")
    if err := cmd.Run(); err != nil {
        t.Fatalf("failed to start docker-compose: %v", err)
    }
    defer func() {
        cmd := exec.Command("docker-compose", "-f", "docker-compose.test.yml", "down")
        cmd.Run()
    }()
    
    // 等待服务就绪
    time.Sleep(5 * time.Second)
    
    // 运行测试
    // ...
}
```

## 五、测试辅助函数

### 5.1 测试环境设置

```go
// ✅ 测试环境设置
type TestEnv struct {
    DB     *sql.DB
    Redis  *redis.Client
    Server *httptest.Server
}

func setupTestEnv(t *testing.T) *TestEnv {
    t.Helper()
    
    env := &TestEnv{}
    
    // 设置数据库
    env.DB = setupTestDB(t)
    
    // 设置 Redis
    env.Redis = setupTestRedis(t)
    
    // 设置服务器
    env.Server = httptest.NewServer(setupRouter(env.DB, env.Redis))
    
    // 清理函数
    t.Cleanup(func() {
        env.Server.Close()
        env.Redis.Close()
        env.DB.Close()
    })
    
    return env
}

func TestIntegration(t *testing.T) {
    env := setupTestEnv(t)
    
    // 使用 env 进行测试
    // ...
}
```

### 5.2 测试数据准备

```go
// ✅ 测试数据准备
func createTestUser(t *testing.T, db *sql.DB) *User {
    t.Helper()
    
    user := &User{
        Name:  "Test User",
        Email: "test@example.com",
    }
    
    err := CreateUser(db, user)
    if err != nil {
        t.Fatalf("CreateUser() error = %v", err)
    }
    
    return user
}

func TestUserIntegration(t *testing.T) {
    db := setupTestDB(t)
    defer db.Close()
    
    user := createTestUser(t, db)
    
    // 使用 user 进行测试
    // ...
}
```

## 六、集成测试最佳实践

### 6.1 核心原则

1. ✅ **使用 build tags**: 分离集成测试和单元测试
2. ✅ **使用独立测试环境**: 不污染生产环境
3. ✅ **使用事务回滚**: 避免测试数据污染
4. ✅ **使用 Docker 容器**: 创建临时测试环境
5. ✅ **清理测试数据**: 确保测试之间不相互影响
6. ✅ **测试真实场景**: 测试多个组件协同工作

### 6.2 测试组织

```
project/
├── internal/
│   ├── user/
│   │   ├── user.go
│   │   ├── user_test.go           # 单元测试
│   │   └── user_integration_test.go  # 集成测试
│   └── service/
│       ├── service.go
│       └── service_test.go
└── test/
    ├── integration/
    │   └── integration_test.go    # 端到端测试
    └── fixtures/
        └── testdata.sql            # 测试数据
```

### 6.3 运行集成测试

```bash
# 运行所有集成测试
go test -tags=integration ./...

# 运行特定包的集成测试
go test -tags=integration ./internal/user

# 并行运行集成测试
go test -tags=integration -parallel 4 ./...

# 显示详细输出
go test -tags=integration -v ./...
```

### 6.4 常见错误

```go
// ❌ 错误 1: 集成测试污染生产数据库
func TestIntegration(t *testing.T) {
    db, _ := sql.Open("mysql", "prod_database")  // 危险！
    // ...
}

// ✅ 好的方式: 使用测试数据库
func TestIntegration(t *testing.T) {
    db := setupTestDB(t)  // 测试数据库
    // ...
}

// ❌ 错误 2: 测试之间相互影响
var globalUser *User

func TestA(t *testing.T) {
    globalUser = createUser()  // 影响其他测试
}

// ✅ 好的方式: 每个测试独立
func TestA(t *testing.T) {
    user := createUser()  // 独立状态
    // ...
}

// ❌ 错误 3: 不清理测试数据
func TestIntegration(t *testing.T) {
    createTestData(t)
    // 没有清理，影响后续测试
}

// ✅ 好的方式: 使用 defer 清理
func TestIntegration(t *testing.T) {
    db := setupTestDB(t)
    defer cleanupTestData(t, db)
    // ...
}
```

## 七、CI/CD 中的集成测试

### 7.1 GitHub Actions 示例

```yaml
# .github/workflows/integration-test.yml
name: Integration Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  integration-test:
    runs-on: ubuntu-latest
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: password
          MYSQL_DATABASE: test_db
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
    
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up Go
        uses: actions/setup-go@v2
        with:
          go-version: 1.19
      
      - name: Run integration tests
        run: go test -tags=integration -v ./...
        env:
          DATABASE_URL: "root:password@tcp(localhost:3306)/test_db"
```

### 7.2 本地运行集成测试

```bash
# 启动测试环境
docker-compose -f docker-compose.test.yml up -d

# 运行集成测试
go test -tags=integration ./...

# 清理测试环境
docker-compose -f docker-compose.test.yml down
```

## 八、总结

### 8.1 关键要点

1. ✅ **使用 build tags**: `// +build integration`
2. ✅ **使用独立测试环境**: 不污染生产环境
3. ✅ **使用事务回滚**: 避免测试数据污染
4. ✅ **使用 Docker 容器**: 创建临时测试环境
5. ✅ **清理测试数据**: 确保测试之间不相互影响
6. ✅ **测试真实场景**: 测试多个组件协同工作

### 8.2 与单元测试的区别

| 特性 | 单元测试 | 集成测试 |
|------|---------|---------|
| **依赖** | 使用 Mock | 使用真实依赖 |
| **速度** | 快 | 慢 |
| **隔离性** | 高 | 低 |
| **覆盖范围** | 单个函数 | 多个组件 |
| **build tag** | 不需要 | 需要 |

记住这些最佳实践，可以编写更可靠、更易维护的集成测试！

