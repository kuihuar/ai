# 接口设计详解

## 一、什么是接口设计？

### 1.1 接口的概念

在 Go 语言中，**接口（Interface）** 定义了一组方法的集合。实现了这些方法的类型就实现了该接口。

```go
// 接口定义
type Writer interface {
    Write([]byte) (int, error)
}

// 任何实现了 Write 方法的类型都实现了 Writer 接口
type File struct{}
func (f *File) Write(data []byte) (int, error) {
    // 实现
}

type Buffer struct{}
func (b *Buffer) Write(data []byte) (int, error) {
    // 实现
}
```

### 1.2 接口设计的优势

1. **解耦**: 接口和实现分离
2. **可扩展**: 可以轻松添加新实现
3. **可测试**: 可以轻松创建 mock 实现
4. **多态**: 同一接口可以有多种实现

## 二、Fiber 的接口设计

### 2.1 Ctx 接口设计

Fiber 使用**接口**而不是具体类型来定义 Context：

```go
// ctx_interface.go
// Ctx 是接口，定义了 Context 的所有方法
type Ctx interface {
    // 请求相关
    Request() *Request
    Method() string
    Path() string
    Params(key string, defaultValue ...string) string
    
    // 响应相关
    Response() *Response
    Status(code int) Ctx
    SendString(body string) error
    JSON(data interface{}) error
    
    // 其他方法...
}

// DefaultCtx 是默认实现
type DefaultCtx struct {
    app      *App
    route    *Route
    fasthttp *fasthttp.RequestCtx
    // ...
}

// DefaultCtx 实现了 Ctx 接口
var _ Ctx = (*DefaultCtx)(nil)  // 编译时检查
```

### 2.2 接口设计的优势

#### 1. 可以自定义实现

```go
// 可以创建自定义的 Context 实现
type CustomCtx struct {
    DefaultCtx  // 嵌入默认实现
    // 添加自定义字段
    UserID int
    Role   string
}

// 实现 Ctx 接口
func (c *CustomCtx) GetUserID() int {
    return c.UserID
}

// 使用自定义 Context
app := fiber.New(fiber.Config{
    NewCtxFunc: func(app *fiber.App) fiber.CustomCtx {
        return &CustomCtx{
            DefaultCtx: *fiber.NewDefaultCtx(app),
        }
    },
})
```

#### 2. 易于测试

```go
// 可以创建 mock 实现用于测试
type MockCtx struct {
    method string
    path   string
    params map[string]string
}

func (m *MockCtx) Method() string {
    return m.method
}

func (m *MockCtx) Path() string {
    return m.path
}

func (m *MockCtx) Params(key string, defaultValue ...string) string {
    if val, ok := m.params[key]; ok {
        return val
    }
    if len(defaultValue) > 0 {
        return defaultValue[0]
    }
    return ""
}

// 测试时使用 mock
func TestHandler(t *testing.T) {
    mockCtx := &MockCtx{
        method: "GET",
        path:   "/users/123",
        params: map[string]string{"id": "123"},
    }
    
    handler(mockCtx)  // 使用 mock 测试
}
```

#### 3. 可扩展性

```go
// 可以扩展接口功能，而不影响现有代码
type ExtendedCtx interface {
    Ctx  // 嵌入基础接口
    
    // 添加新方法
    GetUser() *User
    SetUser(*User)
}

// 新实现可以同时实现两个接口
type MyCtx struct {
    DefaultCtx
    user *User
}

func (c *MyCtx) GetUser() *User {
    return c.user
}
```

### 2.3 接口 vs 具体类型

#### 使用具体类型（Gin 的方式）

```go
// Gin 使用具体类型
type Context struct {
    Request  *http.Request
    Writer   ResponseWriter
    Params   Params
    // ...
}

// 使用
func handler(c *gin.Context) {
    c.JSON(200, gin.H{"message": "pong"})
}
```

**特点**:
- ✅ 简单直接
- ✅ 性能好（无接口调用开销）
- ❌ 难以扩展
- ❌ 难以测试

#### 使用接口（Fiber 的方式）

```go
// Fiber 使用接口
type Ctx interface {
    JSON(data interface{}) error
    SendString(body string) error
    // ...
}

// 使用
func handler(c fiber.Ctx) error {
    return c.JSON(fiber.Map{"message": "pong"})
}
```

**特点**:
- ✅ 易于扩展
- ✅ 易于测试
- ✅ 更灵活
- ⚠️ 有接口调用开销（通常可忽略）

## 三、接口设计的最佳实践

### 3.1 接口应该小而专注

```go
// ✅ 好的设计：小而专注的接口
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

type Closer interface {
    Close() error
}

// 可以组合使用
type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

// ❌ 不好的设计：接口太大
type File interface {
    Read([]byte) (int, error)
    Write([]byte) (int, error)
    Close() error
    Seek(int64, int) (int64, error)
    Stat() (FileInfo, error)
    // ... 太多方法
}
```

### 3.2 接口应该定义行为，而不是数据

```go
// ✅ 好的设计：定义行为
type Formatter interface {
    Format(data interface{}) ([]byte, error)
}

// ❌ 不好的设计：定义数据
type Formatter interface {
    Data interface{}  // 接口不应该包含数据字段
}
```

### 3.3 使用接口组合

```go
// ✅ 好的设计：接口组合
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

// 组合接口
type ReadWriter interface {
    Reader
    Writer
}

// 实现
type Buffer struct{}

func (b *Buffer) Read(data []byte) (int, error) {
    // 实现
}

func (b *Buffer) Write(data []byte) (int, error) {
    // 实现
}

// Buffer 自动实现了 ReadWriter 接口
```

## 四、Fiber 接口设计的实际应用

### 4.1 自定义 Context 实现

```go
// 创建自定义 Context
type MyCtx struct {
    fiber.DefaultCtx
    userID int
    role   string
}

// 添加自定义方法
func (c *MyCtx) GetUserID() int {
    return c.userID
}

func (c *MyCtx) SetUserID(id int) {
    c.userID = id
}

// 使用自定义 Context
app := fiber.New(fiber.Config{
    NewCtxFunc: func(app *fiber.App) fiber.CustomCtx {
        return &MyCtx{
            DefaultCtx: *fiber.NewDefaultCtx(app),
        }
    },
})

// 在中间件中使用
app.Use(func(c fiber.Ctx) error {
    if myCtx, ok := c.(*MyCtx); ok {
        myCtx.SetUserID(123)
    }
    return c.Next()
})
```

### 4.2 接口的扩展性

```go
// 可以轻松添加新功能，而不影响现有代码
type CacheableCtx interface {
    fiber.Ctx
    
    // 添加缓存相关方法
    GetCache(key string) (interface{}, error)
    SetCache(key string, value interface{}, ttl time.Duration) error
}

// 新实现
type CachedCtx struct {
    fiber.DefaultCtx
    cache map[string]interface{}
}

func (c *CachedCtx) GetCache(key string) (interface{}, error) {
    return c.cache[key], nil
}

func (c *CachedCtx) SetCache(key string, value interface{}, ttl time.Duration) error {
    c.cache[key] = value
    return nil
}
```

## 五、总结

### 5.1 接口设计的核心思想

1. **定义行为**: 接口定义"做什么"，而不是"是什么"
2. **小而专注**: 接口应该小而专注，易于实现
3. **组合使用**: 通过接口组合实现复杂功能
4. **可扩展性**: 接口设计应该支持扩展

### 5.2 接口设计的优势

- ✅ **解耦**: 接口和实现分离
- ✅ **可扩展**: 可以轻松添加新实现
- ✅ **可测试**: 可以轻松创建 mock
- ✅ **多态**: 同一接口可以有多种实现

### 5.3 接口设计的适用场景

- ✅ **需要扩展性**: 可能需要多种实现
- ✅ **需要测试**: 需要 mock 实现
- ✅ **需要解耦**: 接口和实现需要分离
- ✅ **框架设计**: 框架需要支持自定义实现

接口设计是优秀框架的重要特征，理解它有助于我们设计更好的 API！

