# 完整调用链示例

本文档通过一个完整的用户创建流程，展示各层之间的调用关系和代码实现。

## 场景：创建用户

### 业务流程
1. 用户提交注册信息（姓名、邮箱、手机号）
2. 验证邮箱和手机号唯一性
3. 数据清理和格式化
4. 保存到数据库
5. 返回用户ID

## 完整代码实现

### 1. API层 - 定义接口规范

**文件**: `api/user/v1/user.go`

```go
// CreateReq 创建用户请求
type CreateReq struct {
    g.Meta `path:"/user" method:"post" tags:"User" summary:"创建用户"`
    Name   string `json:"name"  v:"required|length:2,50#用户名不能为空|用户名长度必须在2-50之间" dc:"用户名"`
    Email  string `json:"email" v:"required|email#邮箱不能为空|邮箱格式不正确" dc:"邮箱"`
    Phone  string `json:"phone" v:"phone#手机号格式不正确" dc:"手机号"`
}

// CreateRes 创建用户响应
type CreateRes struct {
    Id uint `json:"id" dc:"用户ID"`
}
```

**职责**: 
- 定义请求和响应结构
- 定义路由信息
- 定义参数验证规则

---

### 2. Controller层 - 处理HTTP请求

**文件**: `internal/controller/user/user_v1_create.go`

```go
func (c *ControllerV1) Create(ctx context.Context, req *v1.CreateReq) (res *v1.CreateRes, err error) {
    // 1. 参数转换：API层结构 -> DO层结构
    data := &do.User{
        Name:  &req.Name,
        Email: &req.Email,
        Phone: &req.Phone,
    }
    
    // 2. 调用Service层（带业务逻辑验证）
    id, err := service.UserEnhanced.CreateWithValidation(ctx, data)
    if err != nil {
        return nil, err
    }
    
    // 3. 返回响应：DO层数据 -> API层结构
    return &v1.CreateRes{Id: id}, nil
}
```

**职责**:
- 接收HTTP请求
- 参数转换
- 调用Service层
- 返回HTTP响应

**调用**: `service.UserEnhanced.CreateWithValidation()`

---

### 3. Service层 - 业务逻辑编排

**文件**: `internal/service/user_enhanced.go`

```go
func (s *userEnhancedImpl) CreateWithValidation(ctx context.Context, data *do.User) (id uint, err error) {
    // 1. 调用Logic层进行业务逻辑处理
    if err = logic.UserLogic.PrepareUserForCreate(ctx, data); err != nil {
        return 0, err
    }
    
    // 2. 调用DAO层执行数据持久化
    return dao.User.Create(ctx, data)
}
```

**职责**:
- 编排Logic层和DAO层
- 协调业务流程
- 错误处理

**调用**: 
- `logic.UserLogic.PrepareUserForCreate()` - 业务逻辑处理
- `dao.User.Create()` - 数据持久化

---

### 4. Logic层 - 复杂业务逻辑

**文件**: `internal/logic/user.go`

```go
func (l *userLogicImpl) PrepareUserForCreate(ctx context.Context, data *do.User) error {
    // 1. 验证邮箱唯一性
    if data.Email != nil && *data.Email != "" {
        unique, err := l.ValidateEmailUnique(ctx, *data.Email)
        if err != nil {
            return err
        }
        if !unique {
            return errors.New("邮箱已被使用")
        }
    }
    
    // 2. 验证手机号唯一性
    if data.Phone != nil && *data.Phone != "" {
        unique, err := l.ValidatePhoneUnique(ctx, *data.Phone)
        if err != nil {
            return err
        }
        if !unique {
            return errors.New("手机号已被使用")
        }
    }
    
    // 3. 数据清理和格式化
    if data.Name != nil {
        name := g.Trim(*data.Name)  // 去除首尾空格
        data.Name = &name
    }
    
    if data.Email != nil {
        email := g.StrToLower(*data.Email)  // 邮箱转小写
        data.Email = &email
    }
    
    return nil
}

func (l *userLogicImpl) ValidateEmailUnique(ctx context.Context, email string, excludeId ...uint) (bool, error) {
    if email == "" {
        return false, errors.New("邮箱不能为空")
    }

    var user *entity.User
    m := g.DB().Model("users").Ctx(ctx).Where("email", email)
    
    if len(excludeId) > 0 && excludeId[0] > 0 {
        m = m.WhereNot("id", excludeId[0])
    }
    
    err := m.Scan(&user)
    if err != nil {
        return false, err
    }
    
    if user != nil {
        return false, errors.New("邮箱已被使用")
    }
    
    return true, nil
}
```

**职责**:
- 业务规则验证
- 数据预处理
- 复杂业务逻辑

**调用**: 直接使用 `g.DB()` 进行数据查询（用于验证）

---

### 5. DAO层 - 数据访问

**文件**: `internal/dao/user.go`

```go
func (dao *userDao) Create(ctx context.Context, data *do.User) (id uint, err error) {
    result, err := g.DB().Model("users").Ctx(ctx).Data(data).InsertAndGetId()
    if err != nil {
        return 0, err
    }
    return uint(result), nil
}
```

**职责**:
- 封装数据库操作
- SQL执行
- 数据持久化

**操作**: 直接操作数据库

---

### 6. Model层 - 数据模型

**文件**: `internal/model/do/user.go`

```go
type User struct {
    g.Meta `orm:"table:users, do:true"`
    Id     *uint   `orm:"id,primary"       json:"id"`
    Name   *string `orm:"name"             json:"name"`
    Email  *string `orm:"email"            json:"email"`
    Phone  *string `orm:"phone"            json:"phone"`
}
```

**职责**: 定义数据结构

---

## 完整调用链图

```
HTTP请求: POST /user
    ↓
┌─────────────────────────────────────┐
│ Controller: user_v1_create.go       │
│ - 接收 v1.CreateReq                 │
│ - 转换为 do.User                    │
│ - 调用 service.UserEnhanced         │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ Service: user_enhanced.go           │
│ - 调用 logic.UserLogic              │
│ - 调用 dao.User                     │
└─────────────────────────────────────┘
    ↓              ↓
┌──────────┐  ┌──────────────┐
│ Logic    │  │ DAO          │
│ - 验证   │  │ - 执行SQL    │
│ - 格式化 │  │ - 持久化     │
└──────────┘  └──────────────┘
    ↓              ↓
        数据库操作
    ↓              ↓
┌─────────────────────────────────────┐
│ 返回路径（反向）                     │
│ DAO → Service → Controller → HTTP   │
└─────────────────────────────────────┘
```

## 数据流转

### 请求数据流转

```
HTTP Body (JSON)
  {"name":"张三","email":"ZHANG@EXAMPLE.COM","phone":"13800138000"}
    ↓
v1.CreateReq (API层)
  {Name:"张三", Email:"ZHANG@EXAMPLE.COM", Phone:"13800138000"}
    ↓
do.User (DO层)
  {Name:&"张三", Email:&"ZHANG@EXAMPLE.COM", Phone:&"13800138000"}
    ↓
Logic处理 (Logic层)
  - 邮箱转小写: "zhang@example.com"
  - 去除空格: "张三"
  - 验证唯一性: ✓
    ↓
do.User (处理后)
  {Name:&"张三", Email:&"zhang@example.com", Phone:&"13800138000"}
    ↓
SQL INSERT (DAO层)
  INSERT INTO users (name, email, phone) VALUES ('张三', 'zhang@example.com', '13800138000')
    ↓
数据库
  id=1
    ↓
返回响应
  {"id":1}
```

## 错误处理流程

```
1. Logic层验证失败
   ↓
   logic.UserLogic.PrepareUserForCreate() 
   → 返回 error("邮箱已被使用")
   ↓
2. Service层传递错误
   ↓
   service.UserEnhanced.CreateWithValidation()
   → 返回 error("邮箱已被使用")
   ↓
3. Controller层处理错误
   ↓
   controller.Create()
   → 返回 nil, error("邮箱已被使用")
   ↓
4. GoFrame中间件处理
   ↓
   MiddlewareHandlerResponse
   → 返回 HTTP 400 {"code":1, "message":"邮箱已被使用"}
```

## 总结

通过这个完整示例，我们可以看到：

1. **各层职责清晰**: 每层只做自己该做的事
2. **依赖关系明确**: 上层依赖下层，单向依赖
3. **易于测试**: 每层都可以独立测试
4. **易于维护**: 修改某层不影响其他层
5. **代码复用**: Logic和DAO可被多个Service复用

