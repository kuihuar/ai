# Go 单元测试最佳实践

## 一、单元测试基础

### 1.1 测试文件命名

**规则**: 测试文件必须以 `_test.go` 结尾

```go
// ✅ 正确的命名
// user.go
package user

func GetUser(id int) (*User, error) {
    // ...
}

// user_test.go
package user

import "testing"

func TestGetUser(t *testing.T) {
    // ...
}
```

### 1.2 测试函数命名

**规则**: 测试函数必须以 `Test` 开头，后跟被测试的函数名（首字母大写）

```go
// ✅ 正确的命名
func TestGetUser(t *testing.T) { }
func TestCreateUser(t *testing.T) { }
func TestUpdateUser(t *testing.T) { }

// ❌ 错误的命名
func testGetUser(t *testing.T) { }  // 不会被执行
func TestgetUser(t *testing.T) { }   // 不符合规范
```

### 1.3 测试函数签名

**规则**: 测试函数必须接受 `*testing.T` 参数

```go
func TestFunction(t *testing.T) {
    // 测试代码
}
```

## 二、表驱动测试（Table-Driven Tests）

### 2.1 什么是表驱动测试？

**表驱动测试**是 Go 中最常用的测试模式，通过定义测试用例表来测试多种场景。

```go
// ✅ 表驱动测试示例
func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a        int
        b        int
        expected int
    }{
        {
            name:     "positive numbers",
            a:        1,
            b:        2,
            expected: 3,
        },
        {
            name:     "zero",
            a:        0,
            b:        0,
            expected: 0,
        },
        {
            name:     "negative numbers",
            a:        -1,
            b:        -2,
            expected: -3,
        },
        {
            name:     "mixed signs",
            a:        -1,
            b:        1,
            expected: 0,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d, expected %d", tt.a, tt.b, result, tt.expected)
            }
        })
    }
}
```

### 2.2 表驱动测试的优势

1. **覆盖多种场景**: 一个测试函数可以测试多种情况
2. **易于添加新用例**: 只需在表中添加新行
3. **清晰的测试意图**: 每个用例都有明确的输入和期望输出
4. **易于维护**: 测试逻辑集中，易于修改

### 2.3 使用 t.Run 运行子测试

```go
// ✅ 使用 t.Run 运行子测试
func TestDivide(t *testing.T) {
    tests := []struct {
        name     string
        a        int
        b        int
        expected int
        wantErr  bool
    }{
        {
            name:     "normal division",
            a:        10,
            b:        2,
            expected: 5,
            wantErr:  false,
        },
        {
            name:    "divide by zero",
            a:       10,
            b:       0,
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result, err := Divide(tt.a, tt.b)
            if (err != nil) != tt.wantErr {
                t.Errorf("Divide() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !tt.wantErr && result != tt.expected {
                t.Errorf("Divide() = %v, expected %v", result, tt.expected)
            }
        })
    }
}
```

**优势**:
- 每个子测试独立运行
- 可以并行运行：`go test -parallel 4`
- 可以单独运行：`go test -run TestDivide/normal_division`

## 三、测试辅助函数

### 3.1 使用 t.Helper()

**`t.Helper()`** 标记函数为测试辅助函数，在错误报告中跳过该函数。

```go
// ✅ 使用 t.Helper()
func assertEqual(t *testing.T, got, want interface{}) {
    t.Helper()  // 标记为辅助函数
    if got != want {
        t.Errorf("got %v, want %v", got, want)
    }
}

func TestAdd(t *testing.T) {
    result := Add(1, 2)
    assertEqual(t, result, 3)  // 错误会指向这里，而不是 assertEqual 内部
}
```

### 3.2 创建测试辅助函数

```go
// ✅ 创建测试辅助函数
func createTestUser(t *testing.T) *User {
    t.Helper()
    user := &User{
        ID:   1,
        Name: "Test User",
    }
    return user
}

func TestGetUser(t *testing.T) {
    user := createTestUser(t)
    // 使用 user 进行测试
}
```

## 四、错误处理和断言

### 4.1 错误检查

```go
// ✅ 检查错误
func TestReadFile(t *testing.T) {
    data, err := ReadFile("test.txt")
    if err != nil {
        t.Fatalf("ReadFile() error = %v", err)
    }
    if len(data) == 0 {
        t.Error("ReadFile() returned empty data")
    }
}
```

### 4.2 使用 t.Fatal vs t.Error

**区别**:
- `t.Error()`: 记录错误但继续执行测试
- `t.Fatal()`: 记录错误并立即停止测试

```go
// ✅ 使用 t.Fatal 处理致命错误
func TestProcess(t *testing.T) {
    data, err := loadData()
    if err != nil {
        t.Fatalf("loadData() failed: %v", err)  // 立即停止
    }
    
    result := process(data)
    if result == nil {
        t.Error("process() returned nil")  // 继续执行
    }
}
```

### 4.3 使用 testify/assert

```go
// ✅ 使用 testify/assert（需要安装: go get github.com/stretchr/testify/assert）
import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestAdd(t *testing.T) {
    result := Add(1, 2)
    assert.Equal(t, 3, result)
    assert.NotNil(t, result)
    assert.NoError(t, err)
}
```

## 五、测试组织和结构

### 5.1 测试文件组织

```
project/
├── user.go
├── user_test.go        # 单元测试
├── user_integration_test.go  # 集成测试（需要 build tag）
└── internal/
    └── service/
        ├── service.go
        └── service_test.go
```

### 5.2 使用 build tags 分离测试

```go
// ✅ 集成测试使用 build tag
// +build integration

package user

import "testing"

func TestUserIntegration(t *testing.T) {
    // 集成测试代码
}
```

**运行方式**:
```bash
# 运行单元测试
go test ./...

# 运行集成测试
go test -tags=integration ./...
```

### 5.3 测试包命名

**两种方式**:

#### 方式 1: 同一包（推荐用于单元测试）

```go
// user.go
package user

// user_test.go
package user  // 同一包，可以测试未导出函数

func TestGetUser(t *testing.T) {
    // 可以访问未导出的函数和变量
    result := getUser()  // 未导出函数
}
```

#### 方式 2: 测试包（推荐用于集成测试）

```go
// user_test.go
package user_test  // 测试包，只能测试导出函数

import (
    "testing"
    "project/user"
)

func TestGetUser(t *testing.T) {
    // 只能访问导出的函数
    result, err := user.GetUser(1)  // 导出函数
}
```

## 六、Mock 和 Stub

### 6.1 接口 Mock

```go
// ✅ 使用接口进行 Mock
type Database interface {
    GetUser(id int) (*User, error)
}

type mockDatabase struct {
    users map[int]*User
}

func (m *mockDatabase) GetUser(id int) (*User, error) {
    user, ok := m.users[id]
    if !ok {
        return nil, errors.New("user not found")
    }
    return user, nil
}

func TestService(t *testing.T) {
    mockDB := &mockDatabase{
        users: map[int]*User{
            1: {ID: 1, Name: "Test User"},
        },
    }
    
    service := NewService(mockDB)
    user, err := service.GetUser(1)
    if err != nil {
        t.Fatalf("GetUser() error = %v", err)
    }
    if user.Name != "Test User" {
        t.Errorf("GetUser() = %v, want Test User", user.Name)
    }
}
```

### 6.2 使用 gomock

```go
// ✅ 使用 gomock（需要安装: go get github.com/golang/mock/mockgen）
// 生成 Mock: mockgen -source=database.go -destination=database_mock.go

func TestService(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    
    mockDB := NewMockDatabase(ctrl)
    mockDB.EXPECT().GetUser(1).Return(&User{ID: 1, Name: "Test"}, nil)
    
    service := NewService(mockDB)
    user, err := service.GetUser(1)
    // 验证结果
}
```

## 七、测试覆盖率

### 7.1 查看测试覆盖率

```bash
# 查看覆盖率
go test -cover ./...

# 生成覆盖率报告
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out

# 查看详细覆盖率
go test -cover -coverprofile=coverage.out -covermode=atomic ./...
```

### 7.2 覆盖率目标

**建议**:
- 核心业务逻辑: 80%+
- 工具函数: 90%+
- 整体项目: 70%+

```go
// ✅ 使用 -cover 标志
// go test -cover ./...
```

## 八、并行测试

### 8.1 使用 t.Parallel()

```go
// ✅ 并行测试
func TestA(t *testing.T) {
    t.Parallel()  // 标记为可并行
    // 测试代码
}

func TestB(t *testing.T) {
    t.Parallel()  // 标记为可并行
    // 测试代码
}
```

**注意**:
- 只有调用 `t.Parallel()` 的测试才会并行运行
- 并行测试之间不能共享状态
- 使用 `-parallel` 标志控制并行数：`go test -parallel 4`

### 8.2 并行测试的注意事项

```go
// ❌ 不好的方式：共享状态
var globalCounter int

func TestA(t *testing.T) {
    t.Parallel()
    globalCounter++  // 竞态条件
}

// ✅ 好的方式：每个测试独立
func TestA(t *testing.T) {
    t.Parallel()
    counter := 0
    counter++  // 独立状态
}
```

## 九、基准测试

### 9.1 基准测试函数

```go
// ✅ 基准测试
func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(1, 2)
    }
}
```

### 9.2 运行基准测试

```bash
# 运行基准测试
go test -bench=. ./...

# 运行特定基准测试
go test -bench=BenchmarkAdd ./...

# 显示内存分配
go test -bench=. -benchmem ./...

# 比较基准测试
go test -bench=. -benchmem -count=5 ./...
```

### 9.3 基准测试示例

```go
// ✅ 基准测试示例
func BenchmarkStringConcat(b *testing.B) {
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        var s string
        for j := 0; j < 100; j++ {
            s += "a"
        }
    }
}

func BenchmarkStringBuilder(b *testing.B) {
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        var builder strings.Builder
        for j := 0; j < 100; j++ {
            builder.WriteString("a")
        }
        _ = builder.String()
    }
}
```

## 十、测试最佳实践总结

### 10.1 核心原则

1. ✅ **使用表驱动测试**: 覆盖多种场景
2. ✅ **使用 t.Run 运行子测试**: 更好的组织和并行
3. ✅ **使用 t.Helper()**: 标记辅助函数
4. ✅ **使用 t.Fatal 处理致命错误**: 立即停止测试
5. ✅ **使用接口进行 Mock**: 提高可测试性
6. ✅ **保持测试独立**: 不共享状态
7. ✅ **测试覆盖率**: 至少 70%+
8. ✅ **并行测试**: 提高测试速度

### 10.2 测试命名规范

```go
// ✅ 好的测试命名
func TestGetUser_Success(t *testing.T) { }
func TestGetUser_NotFound(t *testing.T) { }
func TestGetUser_InvalidID(t *testing.T) { }
```

### 10.3 测试组织

```go
// ✅ 测试组织示例
func TestUserService(t *testing.T) {
    t.Run("GetUser", func(t *testing.T) {
        t.Run("success", func(t *testing.T) {
            // 测试成功场景
        })
        t.Run("not found", func(t *testing.T) {
            // 测试未找到场景
        })
    })
    
    t.Run("CreateUser", func(t *testing.T) {
        // 测试创建用户
    })
}
```

### 10.4 常见错误

```go
// ❌ 错误 1: 测试函数名不以 Test 开头
func testGetUser(t *testing.T) { }  // 不会被执行

// ❌ 错误 2: 测试函数没有接受 *testing.T
func TestGetUser() { }  // 编译错误

// ❌ 错误 3: 共享状态导致竞态条件
var globalState int

func TestA(t *testing.T) {
    t.Parallel()
    globalState++  // 竞态条件
}

// ❌ 错误 4: 测试依赖执行顺序
func TestA(t *testing.T) {
    // 依赖 TestB 先执行
}

// ✅ 好的方式: 每个测试独立
func TestA(t *testing.T) {
    // 独立测试，不依赖其他测试
}
```

记住这些最佳实践，可以编写更清晰、更可靠、更易维护的单元测试！

