# 零分配路由详解

## 一、什么是零分配路由？

### 1.1 路由匹配的内存分配

在 Web 框架中，**路由匹配**是每个请求都必须执行的操作。如果路由匹配过程中分配内存，在高并发场景下会产生大量分配，影响性能。

#### 传统路由（有分配）

```go
// ❌ 传统路由：每次匹配都分配内存
func matchRoute(path string, routes []Route) *Route {
    // 1. 分配新切片（分配内存）
    parts := strings.Split(path, "/")
    
    // 2. 分配新映射（分配内存）
    params := make(map[string]string)
    
    // 3. 字符串操作（可能分配内存）
    for _, route := range routes {
        if match(path, route, params) {
            return &route  // 可能分配内存
        }
    }
    return nil
}
```

**问题**:
- 每次请求都分配内存
- 高并发时，大量对象被创建
- GC 压力大，性能下降

#### 零分配路由（无分配）

```go
// ✅ 零分配路由：匹配过程不分配内存
func (n *node) getValue(path string, params *Params, ...) (value nodeValue) {
    // 1. 使用传入的 params 指针（不分配新内存）
    // 2. 使用切片扩展而不是创建新切片
    // 3. 使用字符串切片而不是字符串操作
    // 4. 所有操作都在预分配的内存中进行
}
```

**优势**:
- 路由匹配不分配内存
- 减少 GC 压力
- 性能提升显著

## 二、Gin 的零分配路由实现

### 2.1 基于 httprouter 的路由树

Gin 使用 **httprouter**，这是一个零分配的路由库：

```go
// tree.go
type node struct {
    path      string        // 路径前缀
    indices   string        // 子节点索引（字符串，不分配）
    children  []*node       // 子节点（预分配）
    handlers  HandlersChain // 处理器链（预分配）
}

// 路由树结构
type methodTrees []methodTree

type methodTree struct {
    method string
    root   *node
}
```

### 2.2 零分配路由匹配

```go
// tree.go
func (n *node) getValue(path string, params *Params, skippedNodes *[]skippedNode, unescape bool) (value nodeValue) {
    var globalParamsCount int16
    
walk:
    for {
        prefix := n.path
        
        // 1. 字符串比较（不分配内存）
        if len(path) > len(prefix) {
            if path[:len(prefix)] == prefix {
                // 字符串切片（不分配新内存）
                path = path[len(prefix):]
            }
        }
        
        // 2. 遍历索引字符串（不分配内存）
        idxc := path[0]
        for i, c := range []byte(n.indices) {
            if c == idxc {
                n = n.children[i]  // 直接访问，不分配
                continue walk
            }
        }
        
        // 3. 参数提取（在预分配的切片中扩展）
        if params != nil {
            // 只在必要时扩展容量（预分配）
            if cap(*params) < int(globalParamsCount) {
                newParams := make(Params, len(*params), globalParamsCount)
                copy(newParams, *params)
                *params = newParams
            }
            
            // 扩展切片（在预分配的容量内，不分配新内存）
            i := len(*value.params)
            *value.params = (*value.params)[:i+1]  // 只是扩展长度
            
            // 直接赋值（不分配新字符串）
            (*value.params)[i] = Param{
                Key:   n.path[1:],  // 字符串切片，不分配
                Value: val,         // 使用已有的值
            }
        }
        
        // 4. 返回匹配结果（不分配新内存）
        if value.handlers = n.handlers; value.handlers != nil {
            value.fullPath = n.fullPath
            return value
        }
    }
}
```

### 2.3 关键优化技巧

#### 1. 使用切片扩展而不是创建新切片

```go
// ❌ 不好的方式：创建新切片
func extractParams(path string) []Param {
    params := make([]Param, 0)  // 每次分配
    // ...
    return params
}

// ✅ 好的方式：使用预分配的切片扩展
func (n *node) getValue(path string, params *Params, ...) {
    // params 是传入的指针，已预分配容量
    if cap(*params) < int(globalParamsCount) {
        // 只在必要时扩展容量
        newParams := make(Params, len(*params), globalParamsCount)
        copy(newParams, *params)
        *params = newParams
    }
    
    // 扩展切片（在预分配的容量内，不分配新内存）
    *value.params = (*value.params)[:i+1]
}
```

#### 2. 使用字符串切片而不是字符串操作

```go
// ❌ 不好的方式：字符串操作可能分配内存
func extractPath(path string) string {
    return strings.TrimPrefix(path, "/api")  // 可能分配新字符串
}

// ✅ 好的方式：字符串切片不分配内存
func (n *node) getValue(path string, ...) {
    if path[:len(prefix)] == prefix {
        path = path[len(prefix):]  // 字符串切片，不分配新内存
    }
}
```

#### 3. 使用索引字符串而不是映射

```go
// ❌ 不好的方式：使用映射存储索引（分配内存）
type node struct {
    indices map[byte]int  // 映射分配内存
}

// ✅ 好的方式：使用字符串存储索引（不分配内存）
type node struct {
    indices string  // 字符串，不分配新内存
}

// 使用
for i, c := range []byte(n.indices) {
    if c == idxc {
        n = n.children[i]
    }
}
```

### 2.4 路由树的构建

```go
// tree.go
func (n *node) addRoute(path string, handlers HandlersChain) {
    fullPath := path
    n.priority++
    
    // 空树
    if len(n.path) == 0 && len(n.children) == 0 {
        n.insertChild(path, fullPath, handlers)
        n.nType = root
        return
    }
    
walk:
    for {
        // 找到最长公共前缀
        i := longestCommonPrefix(path, n.path)
        
        // 分割边
        if i < len(n.path) {
            child := node{
                path:      n.path[i:],
                children:  n.children,
                handlers:  n.handlers,
                // ...
            }
            n.children = []*node{&child}
            n.path = path[:i]
        }
        
        // 添加子节点
        if i < len(path) {
            path = path[i:]
            c := path[0]
            
            // 检查子节点是否存在
            for i, max := 0, len(n.indices); i < max; i++ {
                if c == n.indices[i] {
                    n = n.children[i]
                    continue walk
                }
            }
            
            // 插入新节点
            n.insertChild(path, fullPath, handlers)
            return
        }
    }
}
```

## 三、零分配路由的性能对比

### 3.1 基准测试

```go
// 测试零分配路由 vs 正常路由
func BenchmarkNormalRouting(b *testing.B) {
    routes := []Route{
        {Path: "/users/:id", Handler: handler},
        {Path: "/posts/:id", Handler: handler},
        // ... 100 个路由
    }
    
    for i := 0; i < b.N; i++ {
        // 每次匹配都分配内存
        matchRoute("/users/123", routes)
    }
}

func BenchmarkZeroAllocationRouting(b *testing.B) {
    tree := buildRouteTree(routes)
    params := make(Params, 0, 10)  // 预分配
    
    for i := 0; i < b.N; i++ {
        // 路由匹配不分配内存
        tree.getValue("/users/123", &params, nil, false)
        params = params[:0]  // 重置长度
    }
}
```

**典型结果**:
```
BenchmarkNormalRouting         100000    15000 ns/op    512 B/op    5 allocs/op
BenchmarkZeroAllocationRouting 1000000     1200 ns/op      0 B/op    0 allocs/op
```

**性能提升**: 约 **12 倍**！

### 3.2 实际应用中的影响

在高并发场景下（10,000 QPS）：

**正常路由**:
- 每秒执行 10,000 次路由匹配
- 每秒分配约 5 MB 内存
- GC 压力大，可能每 50ms 触发一次 GC
- GC 暂停时间：5-20ms

**零分配路由**:
- 每秒执行 10,000 次路由匹配
- 几乎不分配新内存
- GC 压力小，可能每 2-5 秒触发一次 GC
- GC 暂停时间：1-3ms

**性能提升**: 路由匹配延迟降低 **50-80%**！

## 四、零分配路由的实现技巧

### 4.1 预分配参数切片

```go
// ✅ 预分配参数切片
type Engine struct {
    trees methodTrees
}

func (engine *Engine) handleHTTPRequest(c *Context) {
    // 预分配参数切片容量
    if cap(c.Params) < 10 {
        c.Params = make(Params, 0, 10)
    } else {
        c.Params = c.Params[:0]  // 重置长度，不分配新内存
    }
    
    // 路由匹配（不分配新内存）
    value := engine.trees.get(c.Request.Method, c.Request.URL.Path, &c.Params, ...)
}
```

### 4.2 使用字符串切片

```go
// ✅ 使用字符串切片而不是字符串操作
func extractParam(path string, prefix string) string {
    // 字符串切片，不分配新内存
    return path[len(prefix):]
}

// ❌ 避免字符串操作
func extractParam(path string, prefix string) string {
    // strings.TrimPrefix 可能分配新字符串
    return strings.TrimPrefix(path, prefix)
}
```

### 4.3 避免不必要的分配

```go
// ❌ 不好的方式：每次匹配都创建新对象
func matchRoute(path string) *Route {
    // 创建新的 Route 对象（分配内存）
    route := &Route{
        Path:    path,
        Params:  make(map[string]string),  // 分配内存
    }
    return route
}

// ✅ 好的方式：复用预分配的对象
func (n *node) getValue(path string, params *Params, ...) (value nodeValue) {
    // value 是返回值，在栈上分配（不触发 GC）
    // params 是传入的指针，已预分配
    // 所有操作都在预分配的内存中进行
    return value
}
```

## 五、路由树的优化

### 5.1 路由树结构优化

```go
// 优化的路由树结构
type node struct {
    path      string        // 路径前缀
    indices   string        // 子节点索引（字符串，不分配）
    children  []*node       // 子节点（预分配）
    handlers  HandlersChain // 处理器链（预分配）
    priority  uint32        // 优先级（用于排序）
}

// 使用字符串存储索引（不分配内存）
// 例如：indices = "abc" 表示有 3 个子节点，索引分别是 'a', 'b', 'c'
// children[0] 对应 'a'，children[1] 对应 'b'，children[2] 对应 'c'
```

### 5.2 路由匹配优化

```go
// 优化的路由匹配算法
func (n *node) getValue(path string, params *Params, ...) (value nodeValue) {
    // 1. 快速路径匹配（不分配内存）
    if len(path) == len(n.path) && path == n.path {
        // 精确匹配，直接返回
        value.handlers = n.handlers
        return value
    }
    
    // 2. 前缀匹配（不分配内存）
    if len(path) > len(n.path) {
        if path[:len(n.path)] == n.path {
            path = path[len(n.path):]  // 字符串切片
        }
    }
    
    // 3. 子节点匹配（不分配内存）
    idxc := path[0]
    for i, c := range []byte(n.indices) {
        if c == idxc {
            n = n.children[i]
            continue walk
        }
    }
    
    // 4. 参数匹配（在预分配的切片中扩展）
    // ...
}
```

## 六、总结

### 6.1 零分配路由的核心思想

1. **预分配**: 提前分配足够的内存
2. **切片扩展**: 使用切片扩展而不是创建新切片
3. **字符串切片**: 使用字符串切片而不是字符串操作
4. **避免映射**: 使用索引字符串而不是映射

### 6.2 零分配路由的优势

- ✅ **性能提升**: 路由匹配延迟降低 50-80%
- ✅ **减少 GC**: 减少 GC 压力，提升整体性能
- ✅ **高并发**: 适合高并发场景

### 6.3 实现要点

1. **预分配参数切片**: 提前分配足够容量
2. **使用指针传递**: 避免值拷贝
3. **优化数据结构**: 使用高效的数据结构
4. **避免不必要的分配**: 优化算法，减少分配

零分配路由是高性能框架的核心技术，理解它有助于我们编写更高效的路由匹配代码！

