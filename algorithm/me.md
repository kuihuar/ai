## 递归回溯 vs. 分治算法
### 总结
- 分治是“我们一起干，分头工作，最后汇总”。（合作）
- 回溯是“我一条路走到黑，不行就退回来换一条”。（试错）


|特性	|递归回溯 (Recursive Backtracking)	|分治算法 (Divide and Conquer)|
|--|--|--|
|目的	|枚举所有可能性，找到所有（或一个）满足条件的解。	|解决问题本身，将大问题分解为小问题再合并。|
|子问题	|子问题（下一步的选择）之间不是独立的。选择一条路会影响后面的路。	|子问题通常是相互独立的。|
|操作	|核心是 “选择-试探-撤销” 循环。	|核心是 “分解-解决-合并” 流程。|
|结果	|得到所有可能的解集。	|得到原问题的唯一解。|
|经典问题	|全排列、N皇后、组合、数独、图着色	|归并排序、快速排序、二分查找|



|高效算法	|对应的暴力求解思路|
|--|--|
|动态规划 (DP)	|递归回溯。例如斐波那契数列，暴力递归会重复计算大量相同子问题，而DP通过“记忆化”避免了重复。|
|贪心算法 (Greedy)	|枚举所有可能的解序列。例如找零钱问题，暴力法是尝试所有硬币组合，而贪心法是每一步都选当前最优。|
|分治算法 (Divide & Conquer)	|直接进行大规模计算。例如矩阵乘法，标准算法是O(n³)，暴力法就是直接三重循环计算，而Strassen等分治算法通过分解将其优化。|
|回溯算法 (Backtracking)	|生成-测试 (Generate-and-Test)。这是最纯粹的暴力。例如解数独，暴力法是生成所有可能的数字填充组合，然|后检查哪个是正确的。而回溯法会边填边检查，无效就回溯，大大减少了尝试次数。所以回溯本身其实已经是对纯暴力的一种优化了。|
|KMP字符串匹配	|暴力匹配。将模式串与主串逐个字符比较，失败后模式串只向后移动一位。而KMP算法利用next数组，失败后能跳过多个不可能的位置。|