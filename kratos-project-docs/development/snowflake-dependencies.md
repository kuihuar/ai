# 雪花算法依赖说明

## 核心依赖

雪花算法生成器**几乎无外部依赖**，是一个纯内存算法实现。

### 1. 代码依赖（仅标准库和框架）

```go
import (
    "context"    // Go 标准库
    "fmt"        // Go 标准库
    "sync"       // Go 标准库（用于并发安全）
    "time"       // Go 标准库（获取系统时间）
    
    "github.com/go-kratos/kratos/v2/errors"  // Kratos 错误处理
    "github.com/go-kratos/kratos/v2/log"     // Kratos 日志
)
```

### 2. 运行时依赖

#### ✅ 不需要的依赖

- **数据库**：不需要数据库连接，完全内存操作
- **网络**：不需要网络请求
- **外部服务**：不需要调用任何外部服务
- **文件系统**：不需要读写文件
- **配置中心**：配置在初始化时传入，运行时不需要读取配置

#### ⚠️ 需要的依赖

1. **系统时间**（必需）
   - 通过 `time.Now().UnixMilli()` 获取当前时间戳（毫秒）
   - 依赖系统时钟的准确性
   - 如果系统时钟不准确或回拨，可能导致ID重复

2. **配置参数**（初始化时传入）
   - `dataCenterID`：数据中心ID (0-31)
   - `machineID`：机器ID (0-31)
   - 这两个ID必须在集群中唯一，否则可能生成重复ID

3. **内存**（运行时状态）
   - `lastTimestamp`：上次生成ID的时间戳
   - `sequence`：当前序列号
   - 内存占用极小（几个 int64 变量）

## 依赖对比

### 数据库生成器 vs 雪花算法生成器

| 依赖项 | 数据库生成器 | 雪花算法生成器 |
|--------|------------|--------------|
| 数据库连接 | ✅ 必需 | ❌ 不需要 |
| 网络 | ❌ 不需要 | ❌ 不需要 |
| 系统时间 | ✅ 需要（用于时间戳） | ✅ 需要（核心依赖） |
| 配置参数 | ❌ 不需要 | ✅ 需要（数据中心ID、机器ID） |
| 外部服务 | ❌ 不需要 | ❌ 不需要 |
| 文件系统 | ❌ 不需要 | ❌ 不需要 |

## 关键依赖：系统时间

### 为什么依赖系统时间？

雪花算法的核心是基于时间戳生成ID：
- 41位时间戳（毫秒级）
- 如果系统时钟不准确，可能导致：
  1. **时钟回拨**：时间倒退，可能生成重复ID
  2. **时钟过快**：时间跳跃，可能跳过某些ID

### 时钟回拨处理

代码中已实现时钟回拨检测：

```go
// 时钟回拨检查
if now < g.lastTimestamp {
    return 0, fmt.Errorf("clock moved backwards, refusing to generate id for %d milliseconds", g.lastTimestamp-now)
}
```

如果检测到时钟回拨，会返回错误，避免生成重复ID。

### 建议

1. **使用 NTP 同步**：确保服务器时间与标准时间同步
2. **监控时钟偏差**：定期检查系统时钟是否准确
3. **处理时钟回拨错误**：在应用层处理时钟回拨错误，可以：
   - 等待时钟恢复
   - 使用备用生成器（如数据库生成器）
   - 记录告警

## 配置依赖

### 必需配置

```yaml
data:
  number_generator:
    type: "snowflake"
    data_center_id: 1  # 必须在集群中唯一 (0-31)
    machine_id: 1      # 必须在集群中唯一 (0-31)
```

### 配置唯一性要求

- **数据中心ID**：同一数据中心内的所有机器必须使用相同的 `data_center_id`
- **机器ID**：同一数据中心内的每台机器必须使用不同的 `machine_id`
- **全局唯一性**：`(data_center_id, machine_id)` 组合必须在整个集群中唯一

### 配置管理建议

1. **使用配置中心**：通过配置中心统一管理数据中心ID和机器ID
2. **环境变量**：可以通过环境变量设置，避免硬编码
3. **自动分配**：可以基于机器IP、主机名等自动分配机器ID

## 性能依赖

### 无性能瓶颈

雪花算法生成器：
- ✅ 纯内存操作，性能极高
- ✅ 无I/O操作，无网络延迟
- ✅ 无锁竞争（单机内使用 mutex，性能影响极小）
- ✅ 每秒可生成数百万个ID

### 唯一限制

- **同一毫秒内最多4096个ID**：如果超过，会等待下一毫秒
- 实际场景中，这个限制几乎不会触发（需要每秒生成超过400万个ID）

## 总结

雪花算法生成器的依赖非常少：

1. **代码依赖**：仅标准库和 Kratos 框架
2. **运行时依赖**：
   - ✅ 系统时间（必需，但所有服务器都有）
   - ✅ 配置参数（初始化时传入）
   - ✅ 内存（极小）
3. **不需要**：
   - ❌ 数据库
   - ❌ 网络
   - ❌ 外部服务
   - ❌ 文件系统

这使得雪花算法非常适合：
- 高并发场景
- 分布式环境
- 对性能要求极高的场景
- 无法或不想依赖数据库的场景

