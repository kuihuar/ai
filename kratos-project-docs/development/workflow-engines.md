# Go 语言常用流程引擎

## 概述

流程引擎（Workflow Engine）是一种用于编排和执行复杂业务流程的系统，它能够管理长时间运行的任务、处理故障恢复、确保任务执行的可追溯性和可靠性。

在微服务架构中，流程引擎对于协调跨服务的业务流程至关重要，特别是在需要保证最终一致性的分布式事务场景中。

## 为什么需要流程引擎

### 1. 业务场景

- **长时间运行的业务流程**：如订单处理、支付流程、审批流程等
- **跨服务协调**：需要调用多个微服务完成一个业务目标
- **错误处理和重试**：自动处理临时故障，支持重试机制
- **状态管理**：持久化流程状态，支持流程恢复
- **可观测性**：提供流程执行的完整历史记录

### 2. 不使用流程引擎的问题

- **状态丢失**：服务重启导致流程状态丢失
- **错误处理复杂**：需要手动实现重试、补偿等逻辑
- **难以追踪**：缺乏流程执行的完整视图
- **可扩展性差**：难以应对复杂的业务流程

## 主流流程引擎对比

| 引擎 | 开发公司 | 语言支持 | 特点 | 适用场景 |
|------|---------|---------|------|---------|
| **Temporal** | Uber | Go, Java, Python, TypeScript | 功能强大，社区活跃，文档完善 | 通用场景，推荐使用 |
| **Cadence** | Uber | Go, Java, Python | Temporal 的前身，功能类似但维护较少 | 已迁移到 Temporal |
| **Zeebe** | Camunda | Go, Java, Python, C# | BPMN 标准支持，图形化建模 | 需要 BPMN 的场景 |
| **Conductor** | Netflix | Java, Go | 基于 JSON 的工作流定义 | Netflix 内部使用 |
| **自研方案** | - | Go | 轻量级，定制化 | 简单场景，小团队 |

## 详细文档

### 1. Temporal

[Temporal](https://temporal.io/) 是由 Uber 开源的分布式工作流引擎，是目前 Go 语言中最流行和功能最完善的流程引擎。

**特点**：
- ✅ 功能强大，支持复杂的工作流编排
- ✅ 活跃的社区和丰富的文档
- ✅ 支持多种编程语言（Go, Java, Python, TypeScript）
- ✅ 提供 Web UI 用于监控和调试
- ✅ 自动故障恢复和重试机制
- ✅ 支持长时间运行的工作流（可以运行数月）

**适用场景**：
- 复杂的业务流程编排
- 需要高可靠性的长时间运行任务
- 跨服务协调
- 需要完整的执行历史和可观测性

**详细文档**：参见 [Temporal 详细文档](./workflow-engines-temporal.md)

### 2. Zeebe (Camunda)

[Zeebe](https://zeebe.io/) 是 Camunda 开源的 BPMN 工作流引擎，支持 Go 客户端。

**特点**：
- ✅ 基于 BPMN 2.0 标准
- ✅ 提供图形化建模工具（Camunda Modeler）
- ✅ 高性能，支持大规模并发
- ✅ 事件驱动架构
- ✅ 提供 REST API 和 gRPC 接口

**适用场景**：
- 需要 BPMN 标准支持
- 需要图形化工作流建模
- 业务流程需要可视化设计
- 企业级 BPM 需求

**详细文档**：参见 [Zeebe 详细文档](./workflow-engines-zeebe.md)

### 3. Conductor

[Conductor](https://github.com/Netflix/conductor) 是 Netflix 开源的工作流编排引擎。

**特点**：
- ✅ 基于 JSON 的工作流定义
- ✅ 支持任务调度和执行
- ✅ 提供 REST API
- ✅ 支持任务重试和超时
- ✅ Go 客户端支持（社区维护）

**适用场景**：
- Netflix 风格的微服务编排
- JSON 配置驱动的场景
- 任务调度和执行

**详细文档**：参见 [Conductor 详细文档](./workflow-engines-conductor.md)

### 4. 自研方案（Saga 模式）

对于简单场景，可以使用自研的 Saga 编排器。

**特点**：
- ✅ 轻量级，无外部依赖
- ✅ 完全可控，可定制化
- ✅ 适合简单场景

**缺点**：
- ❌ 功能相对简单
- ❌ 需要自行实现重试、监控等功能
- ❌ 可扩展性有限

**项目中的实现**：参见 [Saga 实现文档](../architecture/distributed-event-consistency.md)

## 选择建议

### 选择 Temporal 的情况

- ✅ 需要功能完善、社区活跃的解决方案
- ✅ 需要支持长时间运行的工作流（数天或数月）
- ✅ 需要完整的可观测性和监控
- ✅ 团队有足够的资源学习和维护
- ✅ 需要跨语言支持（Go, Java, Python 等）

### 选择 Zeebe 的情况

- ✅ 需要 BPMN 标准支持
- ✅ 需要图形化工作流建模工具
- ✅ 企业级 BPM 需求
- ✅ 有 Camunda 技术栈经验

### 选择 Conductor 的情况

- ✅ 偏好 JSON 配置驱动
- ✅ Netflix 技术栈
- ✅ 简单的任务编排场景

### 选择自研方案的情况

- ✅ 业务流程简单，步骤较少（< 10 步）
- ✅ 团队规模小，需要快速迭代
- ✅ 对流程引擎功能要求不高
- ✅ 需要完全控制实现细节

## 与项目现有架构的集成

### 当前项目使用 Saga 模式

当前项目实现了基于 Saga 模式的分布式事务编排：

- **位置**：`internal/biz/saga.go`
- **特点**：轻量级，支持补偿事务
- **适用场景**：订单创建、支付流程等简单场景

### 迁移到 Temporal 的建议

如果业务复杂度增加，可以考虑迁移到 Temporal：

1. **评估成本**：学习成本、运维成本
2. **渐进式迁移**：新业务使用 Temporal，旧业务保持 Saga
3. **统一接口**：通过适配器模式统一两种方案的接口

## 性能对比

| 指标 | Temporal | Zeebe | Conductor | 自研 Saga |
|------|----------|-------|-----------|-----------|
| 吞吐量 | 高 | 高 | 中 | 中 |
| 延迟 | 低 | 低 | 中 | 低 |
| 可扩展性 | 高 | 高 | 中 | 低 |
| 学习曲线 | 中 | 中 | 低 | 低 |
| 社区支持 | 高 | 中 | 中 | 无 |

## 参考资源

- [Temporal 官方文档](https://docs.temporal.io/)
- [Zeebe 官方文档](https://docs.camunda.io/)
- [Conductor GitHub](https://github.com/Netflix/conductor)
- [项目 Saga 实现](../architecture/distributed-event-consistency.md)

## 总结

选择合适的流程引擎需要考虑以下因素：

1. **业务复杂度**：简单场景用自研，复杂场景用成熟方案
2. **团队能力**：评估学习和维护成本
3. **技术栈**：考虑与现有技术栈的兼容性
4. **长期规划**：考虑未来的扩展需求

**推荐**：
- **中小型项目**：使用当前项目的 Saga 模式
- **大型项目**：考虑 Temporal 或 Zeebe
- **企业级 BPM**：推荐 Zeebe（Camunda）

