# Canal 架构缓存一致性方案概述

## 什么是 Canal

**Canal** 是阿里巴巴开源的基于 MySQL binlog 的增量订阅和消费组件，可以用于：
- 数据库实时同步
- 缓存一致性保证
- 数据变更通知
- 数据仓库 ETL

## 为什么使用 Canal

### 当前方案的局限性

**Cache-Aside 模式**（当前实现）：
- ✅ 实现简单，业务代码可控
- ⚠️ 需要业务代码显式删除缓存
- ⚠️ 延迟双删可能失效（并发场景）
- ⚠️ 跨服务更新时，缓存可能不一致

**问题场景**：
```
服务A: 更新用户信息 → 删除缓存
服务B: 直接更新数据库（未删除缓存）→ 缓存不一致 ❌
```

### Canal 方案的优势

**基于 Binlog 的变更捕获**：
- ✅ **解耦**：业务代码无需关心缓存删除
- ✅ **可靠**：基于 MySQL binlog，保证数据变更不丢失
- ✅ **实时**：毫秒级延迟，接近实时同步
- ✅ **统一**：所有数据变更统一处理，避免遗漏

## 架构对比

### 方案对比

| 维度 | Cache-Aside（当前） | Canal 架构 |
|------|-------------------|-----------|
| **实现复杂度** | 低 | 中 |
| **业务侵入性** | 高（需要显式删除缓存） | 低（业务代码无需关心） |
| **一致性保证** | 最终一致性（可能短暂不一致） | 最终一致性（更可靠） |
| **跨服务一致性** | 困难（需要协调） | 简单（统一处理） |
| **性能影响** | 无 | 极小（异步处理） |
| **运维复杂度** | 低 | 中（需要 Canal Server） |

### 推荐方案：混合使用

**建议**：
- **高频热点数据**：使用 Canal 自动同步（如用户信息）
- **低频数据**：继续使用 Cache-Aside（如历史订单）
- **实时性要求高**：使用 Canal（如库存、价格）
- **实时性要求低**：使用 Cache-Aside（如统计数据）

## 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                     业务服务层                                │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐                  │
│  │ 订单服务  │  │ 用户服务  │  │ 支付服务  │                  │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘                  │
│       │             │             │                          │
│       └─────────────┴─────────────┘                          │
│                    │                                          │
│                    ▼                                          │
│              ┌──────────┐                                     │
│              │  MySQL   │                                     │
│              │ (主库)    │                                     │
│              └────┬─────┘                                     │
└───────────────────┼──────────────────────────────────────────┘
                    │
                    │ Binlog
                    ▼
         ┌──────────────────────┐
         │   Canal Server       │
         │  (订阅 Binlog)        │
         └──────────┬───────────┘
                    │
                    │ 变更事件
                    ▼
         ┌──────────────────────┐
         │  Canal Client        │
         │  (缓存同步服务)        │
         └──────────┬───────────┘
                    │
                    │ 删除/更新缓存
                    ▼
         ┌──────────────────────┐
         │      Redis           │
         │   (缓存层)            │
         └──────────────────────┘
```

## 核心流程

### 1. 数据变更流程

```
1. 业务服务更新数据库
   ↓
2. MySQL 写入 Binlog
   ↓
3. Canal Server 订阅 Binlog
   ↓
4. Canal Client 接收变更事件
   ↓
5. 解析变更事件（INSERT/UPDATE/DELETE）
   ↓
6. 删除/更新 Redis 缓存
```

### 2. 缓存同步策略

**表变更 → 缓存操作映射**：

| 数据库操作 | 缓存操作 | 说明 |
|----------|---------|------|
| INSERT | 删除缓存 | 新数据可能影响列表缓存，删除后下次查询时重建 |
| UPDATE | 删除缓存 | 数据已变更，删除缓存保证一致性 |
| DELETE | 删除缓存 | 数据已删除，删除缓存 |

**特殊处理**：
- **批量更新**：删除相关缓存键（如用户列表缓存）
- **关联表更新**：删除关联数据缓存（如订单表更新 → 删除用户订单列表缓存）

## 适用场景

### ✅ 适合使用 Canal

1. **高频热点数据**：用户信息、商品信息、库存等
2. **跨服务数据**：多个服务都可能更新的数据
3. **实时性要求高**：需要接近实时的缓存一致性
4. **数据变更频繁**：避免业务代码频繁删除缓存

### ⚠️ 不适合使用 Canal

1. **低频数据**：统计数据、历史数据等
2. **计算型数据**：需要复杂计算的缓存数据
3. **临时数据**：会话数据、临时缓存等

## 实施建议

### 阶段一：基础设施搭建

1. **部署 Canal Server**
   - 配置 MySQL 主从复制
   - 部署 Canal Server 服务
   - 配置数据源和实例

2. **开发 Canal Client**
   - 实现变更事件监听
   - 实现缓存删除逻辑
   - 实现错误处理和重试

### 阶段二：试点应用

1. **选择试点表**
   - 建议从 `users` 表开始
   - 验证缓存同步效果
   - 监控性能和稳定性

2. **逐步扩展**
   - 扩展到 `orders` 表
   - 扩展到 `products` 表
   - 根据业务需求逐步扩展

### 阶段三：混合使用

1. **保留 Cache-Aside**
   - 低频数据继续使用 Cache-Aside
   - 作为 Canal 的降级方案

2. **监控和优化**
   - 监控 Canal 延迟
   - 监控缓存命中率
   - 优化缓存删除策略

## 相关文档

- [Canal 架构设计](./canal-cache-consistency-architecture.md) - 详细架构设计
- [Canal 实现指南](./canal-cache-consistency-implementation.md) - 具体实现步骤
- [Canal 配置说明](./canal-cache-consistency-config.md) - 配置参数说明
- [Canal 监控运维](./canal-cache-consistency-monitoring.md) - 监控和运维指南

## 参考资源

- [Canal 官方文档](https://github.com/alibaba/canal)
- [Canal 快速开始](https://github.com/alibaba/canal/wiki/QuickStart)
- [MySQL Binlog 格式](https://dev.mysql.com/doc/refman/8.0/en/binary-log.html)

