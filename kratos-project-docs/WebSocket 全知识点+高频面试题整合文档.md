# WebSocket 全知识点+高频面试题整合文档

# 一、WebSocket 核心基础认知

## 1.1 定义（面试必背）

WebSocket 是 **HTML5 规范提出的一种基于 TCP 协议的、全双工、长连接的应用层通信协议**，标准协议标识：`ws://`（明文）、`wss://`（加密，基于TLS，生产环境必用）。

## 1.2 核心设计初衷

解决 HTTP 协议在**实时通信场景**的天然缺陷：HTTP是「单工、短连接、请求-响应」模式，客户端必须主动发起请求，服务端才能被动回复，**无法实现服务端主动向客户端推送数据**。

典型适用场景：IM即时通讯、直播弹幕、股票行情、实时监控；若用HTTP实现需靠「轮询/长轮询」，会产生巨大网络开销、延迟高、体验差，WebSocket可完美解决。

## 1.3 通俗理解

HTTP 是「你问我答，不问不答」，WebSocket 是「拨通电话后，双方随时能说话，直到挂电话」。

# 二、WebSocket 核心底层原理 & 连接生命周期（面试高频）

核心特点：**基于TCP的长连接 + 握手阶段复用HTTP + 连接建立后纯TCP通信**。

## 2.1 连接建立：HTTP 握手 + TCP 协议升级（面试必考）

WebSocket 并非完全脱离 HTTP，而是借助 HTTP 完成「协议升级」的握手过程（兼容现有网络架构，如防火墙、网关可识别HTTP请求），完整流程：

1. **客户端发起HTTP协议升级请求**：发送标准HTTP GET请求，携带核心升级标识，示例请求头：
        `GET ws://localhost:8080/im HTTP/1.1
Host: localhost:8080
Connection: Upgrade  # 核心：告知服务端需升级协议
Upgrade: websocket   # 核心：目标协议为websocket
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==  # 随机密钥，用于验证
Sec-WebSocket-Version: 13  # 固定版本号，必须是13`

2. **服务端验证并返回协议升级响应**：校验请求头合法后，返回 HTTP 101 状态码（Switching Protocols），示例响应头：
        `HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=  # 密钥校验结果`

3. **TCP长连接正式建立**：握手成功后，HTTP 连接断开，底层 TCP 连接保留，后续数据交互不再走HTTP，而是纯WebSocket帧数据。

面试考点：WebSocket 是基于 HTTP 的吗？标准答案：**不是**。WebSocket 底层是 TCP 协议，仅握手阶段复用HTTP完成协议升级，连接建立后与HTTP无任何关系，二者是完全独立的协议。

## 2.2 数据通信阶段：全双工、低开销的帧数据传输

连接建立后，通信具备3个核心特征（高性能核心原因）：

1. **全双工通信**：双方在同一TCP连接上，客户端与服务端可随时双向发消息，无主次之分（实时通信核心）；

2. **轻量级数据帧**：帧头仅2~10字节，无HTTP请求头/响应头（动辄几百字节）的冗余开销，**数据传输开销极低**，带宽利用率是HTTP的10倍以上；

3. **支持多类型数据**：原生支持字符串（JSON）、图片、音频、视频等二进制数据，无需额外转码，适配IM消息、文件传输等场景。

## 2.3 连接断开阶段

- 主动关闭：客户端或服务端调用 `close()` 方法，发送关闭帧，双方确认后释放TCP连接；

- 被动断开：网络波动、服务宕机、客户端离线等异常情况，TCP连接会被内核自动释放；

- 核心补充：WebSocket 自带**心跳机制**（ping/pong帧），用于检测「死连接」，避免连接泄漏。

# 三、WebSocket 核心特性（面试必答）

1. **基于 TCP 协议**：复用TCP的可靠性、面向连接特性，数据传输无丢失、无乱序；

2. **全双工通信**：客户端 ↔ 服务端 双向实时通信，核心核心特性；

3. **长连接**：一次连接建立后持续有效，直到主动关闭，无需重复握手，解决HTTP短连接开销问题；

4. **协议升级**：通过HTTP完成握手，兼容现有网络架构，无端口冲突（默认80/ws，443/wss）；

5. **轻量级开销**：帧头小，数据传输效率高，适合高并发、高频次实时数据交互；

6. **原生支持跨域**：不受浏览器同源策略限制，无需配置CORS，天然支持跨域通信；

7. **自带心跳机制**：标准 ping/pong 控制帧，用于保活和链路检测，无需自研；

8. **状态保持**：连接建立后，服务端可识别每个客户端的唯一连接，无需每次请求携带身份信息（如Token）。

# 四、WebSocket 与 HTTP/HTTP2/HTTP3 的核心区别（面试最高频）

## 4.1 基础前提

HTTP1.0/1.1/2/3 均为 **单工、短连接（HTTP1.1支持长连接）、请求-响应模式**，核心规则：**客户端不请求，服务端绝对不能主动推送**。
WebSocket 是 **全双工、长连接、双向通信模式**，核心规则：**连接建立后，双方平等通信，无需请求即可推送**。

## 4.2 核心维度对比表（面试直接答）

|对比维度|HTTP 1.1（最常用）|WebSocket|
|---|---|---|
|通信模式|单工、请求-响应，服务端无主动推送能力|全双工、双向实时通信，服务端可主动推送|
|连接特性|短连接（默认），长连接需配置 `Connection: keep-alive`，一次请求结束后连接释放|真正的长连接，一次握手后永久保持，直到主动关闭|
|数据开销|每次请求携带完整HTTP请求头/响应头，开销大|仅握手阶段有HTTP头，通信阶段只有轻量级帧头，开销极低|
|实时性|极差，实时场景只能轮询/长轮询，延迟≥几百ms|极致，端到端延迟＜1ms，原生实时通信|
|服务端压力|高，轮询产生大量无效请求，占用端口/连接资源|低，一个连接支撑全生命周期通信，资源占用极少|
|跨域支持|受同源策略限制，需配置CORS跨域|天然支持跨域，无任何限制|
|适用场景|普通Web请求、数据查询、页面渲染等「非实时」场景|IM即时通讯、直播弹幕、股票行情、实时监控等「实时」场景|
## 4.3 补充：WebSocket vs HTTP2

HTTP2 支持「服务端推送（Server Push）」，易混淆点（面试坑点）：

HTTP2的「服务端推送」≠ WebSocket的「主动推送」

- HTTP2的推送：**只能推送「静态资源」**（如CSS、JS、图片），是「客户端请求一个页面时，服务端主动推送相关资源」，本质还是「基于客户端请求的被动推送」，无法推送动态业务数据（如IM消息）；

- WebSocket的推送：**推送任意动态数据**，无需客户端触发，是真正的主动推送，完全无依赖。

结论：**HTTP2解决的是「静态资源加载效率」，WebSocket解决的是「动态数据实时通信」，二者无冲突，可共存**。

# 五、WebSocket 与轮询/长轮询的对比（面试高频）

## 5.1 轮询/长轮询定义（HTTP伪实时方案）

WebSocket出现前的折中方案，用于解决实时通信需求，核心是基于HTTP实现。

- **普通轮询**：客户端每隔固定时间（如1s）发起HTTP请求，查询服务端是否有新数据，有则返回，无则返回空。
        

    - 优点：实现简单，无兼容性问题；

    - 缺点：**大量无效请求、实时性差、服务端压力大**，1s轮询延迟≥1s，且产生大量TCP连接/断开。

- **长轮询**：客户端发起HTTP请求后，服务端「挂起请求」，直到有新数据或超时才返回，客户端收到响应后立即重新发起请求。
        

    - 优点：比普通轮询少很多无效请求，实时性稍好（延迟≈数据产生时间）；

    - 缺点：本质还是HTTP请求，**请求头开销大、服务端挂起请求占用大量线程资源**，高并发下易雪崩。

## 5.2 面试标准答案：为什么选WebSocket而非轮询/长轮询？

1. 实时性：WebSocket是真正实时通信，延迟＜1ms；轮询延迟≥几百ms；

2. 资源开销：WebSocket一次连接永久使用；轮询产生大量HTTP请求，占用服务器端口、连接、线程资源；

3. 带宽利用率：WebSocket帧头轻量；轮询的HTTP头开销巨大，带宽浪费严重；

4. 服务端压力：WebSocket服务端压力极低；轮询的服务端压力随并发量指数级增长。

# 六、WebSocket 连接列表核心知识（IM项目核心+面试必考）

## 6.1 连接列表本质（面试直接答）

WebSocket的「连接列表」，本质是服务端内存中维护的、一组【客户端的有效 WebSocket 连接对象】的集合，还会绑定「业务标识（用户ID/群ID/设备ID）」，最终是 **「业务标识 → WebSocket连接对象」的映射关系表**。

通俗理解：服务端=客服中心，WebSocket连接=接通的电话线，连接列表=通话台账，台账记录「谁（用户ID）用哪根电话线（连接对象）通话」，服务端推送消息即「查台账找电话线，对着说话」。

## 6.2 连接列表存储的核心内容（缺一不可）

### 6.2.1 核心：WebSocket 连接对象

以Go语言（主流 `github.com/gorilla/websocket` 库）为例，连接对象为 `conn *websocket.Conn`（Java为`Session`，Node.js为`WebSocket`实例）。

核心作用（IM核心）：

- 向客户端「主动推送消息」：调用 `conn.WriteMessage(...)`；

- 读取客户端「发来的消息」：调用 `conn.ReadMessage(...)`；

- 包含连接状态、读写缓冲区、协议版本等底层信息。

### 6.2.2 业务必备：绑定的业务标识信息

仅存连接对象无用，需绑定标识以区分用户，支撑业务功能：

- **用户ID（userId）**：最核心，用于单聊（如1001、1002）；

- **群ID/房间ID（groupId/roomId）**：用于群聊/广播（如群ID=888，映射「888→[conn1, conn2,...]」）；

- **设备ID（deviceId）**：用于多端登录（区分手机/电脑连接）。

### 6.2.3 生产级数据结构（Go语言IM项目标准写法）

用线程安全的map实现，示例：

```go

// 1. 单聊核心映射：用户ID → 连接对象 (一对一)
var UserConnMap = sync.Map{} // 线程安全map，高并发必用

// 2. 群聊核心映射：群ID → 该群所有连接对象列表 (一对多)
var GroupConnMap = sync.Map{}

// 绑定示例：用户(userId=1001)建立连接后存入
UserConnMap.Store("1001", conn)
```

## 6.3 连接列表的存储位置（按部署模式分）

### 6.3.1 单机部署 → 本地内存

- 适用场景：测试环境、用户量少（≤1万）的小型IM项目；

- 优点：读写速度快（内存操作）、实现简单；

- 缺点：无法水平扩容、单点故障（服务器宕机丢失所有连接）、集群部署时连接列表单机隔离（跨节点推送失效）。

### 6.3.2 集群部署（生产必用）→ 网关层内存+分布式缓存

核心设计：后端业务服务不维护全局连接列表，由WebSocket网关（emitter/nezha）统一维护，分两层存储：

- 网关本地内存：维护当前节点的连接列表（userId→conn），负责本地连接推送；

- 分布式缓存（Redis）：存储「全局用户ID→网关节点地址」映射（如「1001→网关节点A」）。

跨节点推送逻辑：用户A连网关A，用户B连网关B → 网关A查Redis找到B的节点B → 网关A转发消息给网关B → 网关B查本地列表推送消息给B。

## 6.4 连接列表的核心维护逻辑（生产必写+面试必考）

### 6.4.1 新增连接 → 存入列表

用户WebSocket握手成功+鉴权通过后，立即将「userId + conn对象」存入map。

### 6.4.2 核心必做：断开连接 → 从列表删除（90%新手踩坑）

不删除的后果：内存泄漏（无效conn堆积耗尽内存）、推送报错（调用无效conn.Write报错panic）。

删除时机（必写3个）：

- 客户端主动断开：监听WebSocket的`OnClose`事件；

- 心跳超时断开：检测到心跳超时，判定连接失效；

- 服务端主动踢人：用户异地登录、账号封禁等场景。

Go语言生产级删除代码示例：

```go

// 监听连接关闭事件，断开后自动删除
go func() {
    defer func() {
        UserConnMap.Delete(userId) // 从map删除
        _ = conn.Close() // 关闭连接释放资源
    }()
    // 循环读取客户端消息，读取失败即连接断开
    for {
        _, _, err := conn.ReadMessage()
        if err != nil {
            break
        }
    }
}()
```

### 6.4.3 进阶必做：加线程安全锁

WebSocket服务是高并发场景，普通map非线程安全，并发读写会panic。生产环境用 `sync.Map`（读多写少，适配IM场景）或 `map + sync.RWMutex`（读写均衡）。

# 七、生产环境核心问题 & 解决方案（面试必考+IM项目必备）

## 7.1 问题1：WebSocket 连接数限制？如何支撑高并发？

### 现象

单台服务器WebSocket连接数默认有限制（如Linux默认文件句柄数1024），超过后无法建立新连接。

### 原因

每个WebSocket连接对应一个TCP连接，占用一个「文件句柄」，操作系统对进程的文件句柄数有默认上限。

### 解决方案（面试答全满分）

1. 修改系统内核参数：Linux下修改 `/etc/security/limits.conf`，增大文件句柄数（如 `* soft nofile 655350`、`* hard nofile 655350`）；

2. 服务端配置优化：Go服务设置 `runtime.GOMAXPROCS`、关闭TCP的TIME_WAIT；Java服务调整线程池参数；

3. 引入WebSocket网关：如emitter-io/emitter、nezha，网关做「统一接入+负载均衡」，分发连接到后端集群，水平扩容支撑百万/千万级连接；

4. 核心结论：WebSocket连接数理论无上限，通过「系统调优+集群部署」可无限扩容。

## 7.2 问题2：WebSocket 如何做身份认证？

### 问题

握手阶段是HTTP请求，通信阶段是纯TCP，无法在通信阶段携带Token/JWT，需保证连接合法性。

### 解决方案（生产常用，面试答任意一种即可）

1. 方案1：握手阶段URL带认证信息（首选，最简单）
        客户端连接时URL携带Token：`ws://localhost:8080/im?token=xxx`，服务端握手阶段解析Token校验，非法则拒绝升级协议。优点：实现简单、无侵入、性能高；缺点：Token暴露在URL（生产用wss://加密，无安全问题）。

2. 方案2：握手阶段请求头带认证信息
        客户端在握手请求头携带 `Authorization: Bearer xxx`，服务端解析校验，安全性更高。

## 7.3 问题3：WebSocket 如何处理断线重连？

### 现象

网络波动（4G切WiFi、地铁隧道）、服务端重启导致连接断开，客户端收不到推送、消息丢失。

### 解决方案（完整方案，面试答全）

1. 客户端断线检测：监听WebSocket的 `onclose`、`onerror` 事件，检测到断开立即触发重连；

2. 指数退避重连策略：按「1s→2s→4s→8s→30s」间隔重试（最大30s），避免短时间大量重连压垮服务端；

3. 服务端连接恢复：通过「用户ID」绑定连接，重连成功后自动恢复消息推送、在线状态；

4. 离线消息缓存：服务端缓存用户离线消息，重连成功后主动推送未读消息，保证消息不丢失（IM必备）。

## 7.4 问题4：WebSocket 如何做心跳保活？

### 问题

客户端断网、手机息屏、防火墙超时导致TCP连接「假死」（连接存在但无法通信），服务端占用资源。

### 解决方案（标准方案，原生支持）

WebSocket 协议内置 ping/pong 控制帧，无需自研：

1. 客户端定时发ping帧：每隔30s发送空数据ping帧；

2. 服务端自动回复pong帧：收到ping后原生回复，无需业务代码；

3. 超时判定：客户端超过90s未收pong → 重连；服务端超过90s未收ping → 主动关闭连接释放资源。

核心参数：心跳间隔30s，超时时间90s（行业最佳实践）。

## 7.5 问题5：WebSocket 支持广播/群聊吗？如何实现？

支持，IM核心需求，两种实现方案：

1. 服务端内存广播：单台服务端维护「房间/群ID → 连接列表」映射，收到消息遍历列表推送；

2. 分布式广播：集群部署时用消息队列（Redis Pub/Sub、Kafka），网关收消息后发布到队列，所有服务端订阅并推送本地连接（如emitter网关实现）。

## 7.6 问题6：服务器重启/宕机，内存中连接列表丢失怎么办？

### 核心问题

内存是易失性存储，重启后连接列表全部丢失，引发：所有客户端连接失效、业务映射关系丢失、在线状态混乱。

### 解决方案（四层防护，用户无感知）

1. 第一层（核心根基）：客户端无感重连


    - 精准识别失效：监听onclose/onerror + 心跳检测（双保险）；

    - 指数退避+负载均衡重试：重连地址指向负载均衡域名，避免连故障节点；

    - 无感恢复：重连后重新鉴权、拉取离线消息、刷新在线状态、重新加入群聊。

2. 第二层（核心保障）：服务端全链路数据持久化
        核心业务数据（离线消息、用户信息、群成员、在线状态）全部存入Redis/MySQL，网关仅存临时连接对象，重启后数据不丢失。

3. 第三层（核心设计）：网关无状态化
        网关节点不存任何需持久化的业务数据，所有数据来自Redis/MySQL或客户端请求，节点平等可替换，支持随意重启、扩容。

4. 第四层（进阶优化）：网关高可用兜底
        

    - 优雅重启：重启前主动发关闭帧通知客户端重连，空窗期缩至毫秒级；

    - 连接信息预热：重启后从Redis拉取用户列表，提前构建映射；

    - 集群消息同步：通过Redis Pub/Sub同步群消息，避免积压。

## 7.7 问题7：网关层重启/宕机怎么办？

### 核心认知

网关集群部署（至少2节点），单节点重启仅影响该节点用户，其他节点正常运行，业务不中断。

### 解决方案（与服务器重启方案一致，补充集群适配）

1. 客户端：无感重连（指数退避+负载均衡重试），重连后恢复业务状态；

2. 网关：无状态化设计+优雅重启，重启前通知客户端，重启后从Redis拉取用户元信息预热；

3. 架构：负载均衡器做健康检查，自动剔除故障节点，客户端请求分发到健康节点；

4. 数据：核心业务数据持久化到Redis/MySQL，消息零丢失。

## 7.8 问题8：网关需要持久化吗？

### 结论前置（面试标准答案）

**WebSocket网关「99%的核心内容不需要持久化，仅极少量非核心临时数据可选持久化」**。核心原则：网关是「无状态的连接转发层」，持久化是优化项；「无状态化 + 核心业务数据外部持久化」是生产硬性要求。

### 为什么几乎不需要持久化？

1. 网关核心职责是连接转发/消息推送，非数据存储，无持久化刚需；

2. 无状态化是最高优先级，持久化会破坏无状态，导致重启慢、扩容复杂；

3. 网关内存核心数据是「连接对象（conn）」，是进程绑定的TCP句柄，无法序列化、无法持久化，重启后客户端重连即可重建；

4. 所有需持久化的核心数据（离线消息、用户信息等）均由Redis/MySQL兜底，无需网关越俎代庖。

### 可选持久化的非核心数据（优化项）

1. 用户连接元信息（存Redis）：如「userId→{deviceId, gatewayNode, lastActiveTime}」，优化重连后业务恢复速度；

2. 网关运行时监控指标（存本地文件/时序数据库）：如连接数、消息转发量，用于运维排查，丢了无影响。

### 绝对禁止持久化的数据（生产红线）

- WebSocket连接对象（conn）：序列化不了，存了无用；

- 核心业务数据（离线消息、用户信息等）：应交给Redis/MySQL；

- 网关核心配置（端口、负载规则等）：应存在配置文件/配置中心。

# 八、IM项目终极高可用架构（Go+Kratos+WebSocket网关）

完整链路：

```text

客户端(APP/网页) ←→ 负载均衡(Nginx/云负载均衡) ←→ WebSocket网关集群(emitter/nezha/自研) ←→ Kratos微服务集群
                                                                 ↓
                                                          Redis + MySQL (持久化存储)
```

## 各层职责

1. 客户端：断线检测、指数退避重连、业务状态恢复、静默补发消息；

2. 负载均衡：统一入口、分发连接请求、健康检查（剔除故障网关）；

3. WebSocket网关集群：无状态、维护连接列表、消息转发、跨节点路由、优雅重启；

4. Kratos微服务集群：无状态、处理业务逻辑（用户认证、消息存储、群聊管理）；

5. Redis+MySQL：Redis存缓存/半持久化数据（离线消息、在线状态、网关映射）；MySQL存全持久化核心业务数据（用户信息、好友关系、群配置）。

# 九、高频面试题及标准答案（按频率排序）

## 9.1 基础必考题（100%问到）

1. **Q：WebSocket 是什么？核心特点是什么？**A：WebSocket是基于TCP的全双工、长连接的应用层协议。核心特点：① 全双工通信，服务端可主动推送；② 长连接，一次握手永久有效；③ 轻量级开销，帧头小；④ 天然跨域；⑤ 基于TCP，可靠性高。

2. **Q：WebSocket 和 HTTP 的区别是什么？为什么不用HTTP做实时通信？**A：核心区别是通信模式和连接特性：HTTP是单工、请求-响应、短连接，服务端无主动推送能力，实时性差、开销大；WebSocket是全双工、双向通信、长连接，服务端可主动推送，实时性极致、开销低。HTTP做实时通信只能用轮询，产生大量无效请求，服务端压力大、体验差，故不适用。

3. **Q：WebSocket 是基于HTTP的吗？为什么握手阶段要用HTTP？**A：不是，WebSocket底层是TCP协议，与HTTP无关。握手用HTTP是为了兼容现有网络架构（防火墙、网关可识别HTTP请求），避免被拦截，降低协议升级成本。

4. **Q：WebSocket 的连接过程是怎样的？**A：① 客户端发起HTTP GET请求，携带`Upgrade: websocket`等升级头；② 服务端校验后返回HTTP 101状态码，确认协议升级；③ 握手成功，TCP连接保留，双方开始全双工通信。

5. **Q：WebSocket 如何做身份认证？**A：在握手阶段完成认证：① URL携带Token（如`ws://xxx?token=xxx`）；② 请求头携带Authorization（如`Bearer xxx`），服务端校验通过后才允许升级协议，通信阶段无需再认证。

6. **Q：WebSocket 连接列表里保存的是什么？为什么要存这些？**A：保存「客户端WebSocket连接对象」+「绑定的业务标识（用户ID/群ID）」，核心是映射表。存连接对象是因为它是唯一通信管道，实现消息推送；存用户ID是为了区分连接归属，实现精准点对点推送，仅存连接对象无法区分用户，无实际意义。

7. **Q：客户端断开连接后，为什么必须从连接列表删除？不删有什么问题？**A：必须删除，否则会导致：① 内存泄漏，无效连接对象堆积耗尽内存，服务崩溃；② 推送报错，查询到无效连接对象，调用Write方法会panic。删除时机：客户端主动关闭、心跳超时、服务端主动踢人。

8. **Q：Go语言中，WebSocket的连接对象是什么？如何实现消息推送？**A：用gorilla/websocket库的`*websocket.Conn`作为连接对象。调用`conn.WriteMessage()`推送消息，调用`conn.ReadMessage()`读取客户端消息。

9. **Q：WebSocket 连接列表存在内存中，服务器重启了怎么办？**A：问题：连接列表丢失，所有客户端连接失效、业务映射丢失、状态混乱。解决：① 客户端：心跳检测+指数退避重连，重连后重新鉴权；② 服务端：核心业务数据持久化到Redis/MySQL，重启后数据不丢失；③ 架构：小体量用单机快照，中大型用WebSocket网关集群，实现无感知重启。

10. **Q：WebSocket网关需要做持久化吗？为什么？**A：几乎不需要。原因：① 网关职责是连接转发，非数据存储，无刚需；② 无状态化是核心设计，持久化会破坏无状态；③ 核心数据是连接对象，无法序列化持久化，重启后客户端重连即可重建。仅可选持久化用户连接元信息、监控指标等非核心数据优化体验。

## 9.2 进阶高频题（80%问到）

1. **Q：WebSocket 为什么能实现全双工通信？HTTP为什么不行？**A：① WebSocket基于TCP的全双工特性，TCP本身支持双方同时读写，WebSocket封装了这一能力；② HTTP是应用层协议，定义了「请求-响应」的单工规则，即使TCP是全双工，HTTP也限制了服务端主动推送能力。

2. **Q：WebSocket 如何处理断线重连和心跳保活？**A：① 断线重连：客户端监听onclose/onerror事件，触发后用指数退避策略重试，重连成功后拉取离线消息、恢复状态；② 心跳保活：原生支持ping/pong帧，客户端30s发ping，服务端自动回pong，90s超时未收到则判定连接失效，主动关闭或重连。

3. **Q：WebSocket 连接数受限的原因是什么？如何解决？**A：原因：每个连接对应一个TCP连接，占用文件句柄，操作系统对进程文件句柄数有默认上限。解决：① 修改Linux内核参数增大文件句柄数；② 服务端配置优化；③ 引入WebSocket网关做集群负载均衡，水平扩容支撑高并发。

4. **Q：WebSocket 支持跨域吗？为什么？**A：天然支持跨域，无同源策略限制。因为同源策略是浏览器为HTTP协议设计的安全限制，WebSocket是独立协议，仅握手阶段复用HTTP，通信阶段与HTTP无关，故不受限制。

5. **Q：轮询、长轮询、WebSocket 的区别？各自适用场景？**A：① 轮询：客户端定时请求，实现简单、实时性差，适合低并发弱实时场景；② 长轮询：服务端挂起请求至有数据，实时性稍好，适合中小并发伪实时场景；③ WebSocket：全双工实时通信，实时性极致、开销低，适合高并发强实时场景（IM、直播、行情）。

6. **Q：单机和集群部署，WebSocket连接列表存储有什么区别？集群如何实现跨节点推送？**A：单机存本地内存，实现简单但无法扩容；集群由WebSocket网关统一维护，本地内存存当前节点连接，Redis存「用户ID→网关节点地址」映射。跨节点推送：网关查Redis找到用户所在节点，转发消息至该节点，节点查本地列表推送。

7. **Q：网关无状态化设计的好处是什么？与持久化的关系？**A：好处：① 节点可随意重启、扩容；② 负载均衡均匀分发请求；③ 运维成本低。关系：对立且互补，无状态化要求网关不存需持久化的核心数据，持久化需求由外部Redis/MySQL满足，兼顾高可用与数据安全。

8. **Q：IM项目中，如何保证消息零丢失？即使服务器/网关重启？**A：核心是「消息持久化+离线推送」：服务端收到消息先存入Redis离线消息队列，再尝试推送；推送成功则删除，失败则保留；重启后用户重连，服务端从Redis拉取离线消息推送，保证零丢失。

## 9.3 大厂深度题（30%问到，加分项）

1. **Q：WebSocket 在微服务架构中如何落地？需要注意什么？**A：核心方案：引入WebSocket网关做统一接入层，架构为「客户端→网关→微服务集群」。注意点：① 网关负载均衡分发连接；② 网关维护「用户ID-连接」全局映射，实现跨节点推送；③ 微服务专注业务逻辑，不处理连接；④ Redis缓存离线消息和在线状态，保证分布式一致性。

2. **Q：WebSocket 和 Socket.IO 的区别？生产环境选哪个？**A：① WebSocket是标准协议，原生支持、无依赖、性能高；② Socket.IO是封装库，优先用WebSocket，不支持则降级为长轮询，兼容性好。选型：需兼容老旧浏览器（如IE）选Socket.IO；现代浏览器/APP优先原生WebSocket，性能更高。

3. **Q：WebSocket 如何保证消息的可靠性？（不丢失、不重复、不乱序）**A：① 不丢失：服务端缓存离线消息，重连后推送；消息发送后等待服务端确认，未确认则重试；② 不重复：消息加唯一ID，客户端收到后去重；③ 不乱序：依赖TCP的有序传输特性，TCP保证数据顺序，WebSocket无需额外处理。

4. **Q：WebSocket 的数据帧结构是怎样的？为什么开销低？**A：帧头仅2~10字节，包含操作码、掩码、数据长度等核心信息，无冗余字段；而HTTP请求头动辄几百字节，故WebSocket传输开销极低，带宽利用率高。

5. **Q：WebSocket 可以传输二进制数据吗？如何传输大文件？**A：可以，原生支持文本和二进制数据帧。传输大文件时，将文件分片为二进制帧分批次发送，客户端接收后拼接，无需额外转码，性能与TCP一致。

# 十、核心知识点总结（一分钟回顾）

1. WebSocket 核心：基于TCP全双工长连接，握手复用HTTP，连接建立后与HTTP无关，解决实时通信需求；

2. 连接列表核心：存储「用户ID+连接对象」映射，单机存内存，集群靠网关+Redis，断开必须删除，需线程安全；

3. 生产核心问题：连接数限制（系统调优+集群）、认证（握手阶段）、断线重连（指数退避）、心跳（ping/pong）、消息零丢失（持久化+离线推送）；

4. 网关设计核心：无状态化，几乎不持久化，集群部署+负载均衡实现高可用，重启靠客户端重连+外部数据兜底；

5. IM终架构：客户端→负载均衡→网关集群→微服务集群→Redis+MySQL，各司其职，实现高可用、可扩容、消息零丢失。
> （注：文档部分内容可能由 AI 生成）