# 协程与线程
1. 调度者不同：线程是内核态线程，由操作系统内核调度（抢占式）；协程是用户态线程，由用户程序或运行时库自己调度（协作式）。

2. 开销不同：线程创建、上下文切换需要进入内核态，开销大；协程的切换在用户态完成，开销极小。

3. 资源占用不同：线程默认栈大小在MB级别（如1-2MB）；协程栈通常在KB级别（如几KB），可以轻松创建成千上万个。

4. 同步方式不同：线程间共享内存，需要用锁等机制来保证安全，易出错；协程通过通道通信来共享内存，更安全。”

## GMP
一、核心答案（首先给出一个高度概括的定义）
“GMP模型是Go语言运行时（runtime）用于实现并发调度的高效机制。它的核心思想是在有限的操作系统线程（M）上，调度执行大量的用户级协程（G），并通过一个全局队列和本地队列来管理这些协程，同时利用多核处理器（P）来实现真正的并行。”

一句话总结：G是任务，M是工人，P是生产资料和流水线。Go调度器的作用就是让有限的工人（M），在有生产线（P）的情况下，高效地完成大量的任务（G）。

二、详细阐述三个组件（解释G、M、P分别是什么）
1. G (Goroutine)
是什么：就是Go的协程，一个轻量级的用户态线程。包含了执行栈、指令指针、以及一些用于调度的信息。

特点：创建开销极小（初始仅几KB），可以动态扩缩栈。我们编写的 go func() 就是创建了一个G。

2. M (Machine)
是什么：代表着操作系统内核线程。它是真正在CPU上执行代码的实体。

特点：M是由操作系统管理的，创建和切换成本较高。一个M必须持有一个P才能执行G。

3. P (Processor)
是什么：可以看作是一个逻辑处理器或调度上下文。它包含了运行Go代码所需要的资源，比如本地Goroutine运行队列（LRQ）。

特点：

P的数量默认等于CPU的核心数（可通过 GOMAXPROCS 环境变量设置），它决定了最多有多少个G可以真正并行执行。

P是G和M之间的一个中间层，有了P，Go调度器才能实现工作窃取（Work Stealing） 等复杂的调度策略，极大地提高了效率。


三、GMP的工作流程与调度策略（这是回答的重点）
你需要解释G是如何被调度到M上去执行的。

创建Goroutine (G)：

当我们执行 go func() 时，会创建一个新的G。

这个G首先会被放入当前P的本地运行队列（LRQ）。如果LRQ满了，则放入全局运行队列（GRQ）。

M获取P并执行G：

一个M需要绑定一个P才能开始执行G。

M会从它绑定的P的LRQ中取出一个G来执行（schedule函数）。

当M执行完当前的G后，它会再次尝试从P的LRQ中获取下一个G。

调度器的两大核心策略：

工作窃取 (Work Stealing)：

当一个P的LRQ为空（没有G可执行）时，它不会傻等着，而是会：

首先从全局队列（GRQ）获取一批G。

如果全局队列也为空，则随机从另一个P的LRQ中偷走一半的G到自己的本地队列。

好处：避免了某些M空闲而其他M忙不过来的情况，充分利用了系统资源。

系统调用阻塞处理 (Syscall)：

当正在执行G的M发生了阻塞性系统调用（如文件IO、网络IO）时，这个M会被操作系统挂起。

Go运行时很聪明，它会将这个M和它绑定的P分离（Hand Off）。

然后，运行时會创建一个新的M（或从休眠M队列中取一个），来接管刚才那个P，继续执行P的LRQ里的其他G。

当阻塞的系统调用完成后，那个被挂起的G会尝试：

找到一个空闲的P，在这个P上继续执行。

如果找不到空闲的P，这个G会被标记为可运行状态，放回全局队列（GRQ），然后这个M会进入休眠状态。

好处：保证了即使有G阻塞，也不会影响到P上其他G的执行，最大化了CPU的利用率。 这是Go能高效处理高并发的关键。

网络I/O处理：

Go通过Netpoller将异步I/O模拟为阻塞I/O。

当G进行网络I/O时，它会被异步阻塞：G会被移动到Netpoller中等待，而M不会被阻塞，它可以继续执行P LRQ中的其他G。


画图辅助理解
当网络数据到达时，Netpoller会通知对应的G，并将其放回某个P的LRQ中等待执行。

      Global Run Queue (GRQ)
      |    |    |    |    |
      ---------------------
            ^    |
            |    v (Work Stealing)
   +--------|---------|--------+
   |   P1   |   P2    |   P3   |  (Processors, GOMAXPROCS=3)
   | [LRQ]  |  [LRQ]  |  [LRQ] |
   | G->G->G| G->G->G | (empty)|
   +----|---+----|----+----|---+
        | binds  | binds   | binds
        v        v         v
       M1       M2        M3   (Threads, created as needed)