# Go语言同步原语全面学习指南

## 1. 同步原语的定义

同步原语是操作系统或编程语言提供的基础同步机制，用于协调多个并发执行单元（如线程、goroutine）之间的执行顺序和资源访问。

**核心特征**：
- **基础性** - 构建更复杂同步机制的基础
- **原子性** - 操作不可分割
- **简单性** - 明确的单一职责
- **组合性** - 可组合构建复杂同步逻辑

## 2. 同步原语的分类

### 2.1 锁类同步原语
- **互斥锁（Mutex）** - 最基本的独占锁
- **读写锁（RWMutex）** - 允许多读单写的锁
- **自旋锁（SpinLock）** - 基于忙等待的锁
- **可重入锁（ReentrantLock）** - 允许同一持有者重入的锁
- **公平锁（FairLock）** - 按请求顺序获取的锁
- **升降级锁（UpgradeLock）** - 支持读写锁升级降级的锁

### 2.2 协调类同步原语
- **条件变量（Cond）** - 基于条件的等待和通知机制
- **等待组（WaitGroup）** - 等待多个goroutine完成
- **屏障（Barrier）** - 多个goroutine在特定点汇合
- **信号量（Semaphore）** - 控制并发数量的计数器

### 2.3 原子操作
- **原子操作（atomic）** - 无锁的原子读写操作
- **原子计数器** - 基于原子操作的计数器

## 3. 同步原语的核心作用

### 3.1 解决数据竞争（Data Race）
```go
// 使用互斥锁保护共享数据
type Counter struct {
    mu    sync.Mutex
    count int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.count++ // 临界区操作
}
```

### 3.2 控制执行顺序
```go
// 使用等待组控制执行顺序
func main() {
    var wg sync.WaitGroup
    
    wg.Add(1)
    go func() {
        defer wg.Done()
        // 子任务
    }()
    
    wg.Wait() // 等待子任务完成
}
```

### 3.3 条件等待
```go
// 使用条件变量等待特定条件
for !condition {
    cond.Wait() // 等待条件满足
}
```

### 3.4 资源控制
```go
// 使用信号量控制资源访问
semaphore.Acquire() // 获取资源许可
// 使用资源
semaphore.Release() // 释放资源许可
```

## 4. 同步原语的层次结构

```
同步原语
├── 锁类（Lock-based）
│   ├── 互斥锁
│   ├── 读写锁
│   ├── 自旋锁
│   └── 特殊锁（可重入、公平、升降级）
├── 协调类（Coordination）
│   ├── 条件变量
│   ├── 等待组
│   ├── 屏障
│   └── 信号量
└── 原子类（Atomic）
    ├── 原子操作
    └── 原子计数器
```

## 5. 为什么叫"原语"？

"原语"意味着这些是最基础的、不可再分的同步机制：

### 5.1 基础性
- 它们是构建更复杂同步机制的基础
- 其他高级同步模式都基于这些原语实现

### 5.2 原子性
- 它们的操作是不可分割的
- 要么完全执行，要么完全不执行

### 5.3 简单性
- 每个原语都有明确的单一职责
- 接口简单，易于理解和使用

### 5.4 组合性
- 可以组合使用构建复杂的同步逻辑
- 支持多种同步模式的组合

## 6. 同步原语的选择原则

### 6.1 根据问题类型选择
- **数据保护** → 互斥锁、读写锁
- **条件等待** → 条件变量
- **任务协调** → 等待组、屏障
- **资源控制** → 信号量
- **性能优化** → 原子操作

### 6.2 根据性能要求选择
- **高并发读** → 读写锁
- **短时间锁定** → 自旋锁
- **无锁场景** → 原子操作
- **复杂协调** → 条件变量组合

### 6.3 根据公平性要求选择
- **公平访问** → 公平锁
- **写者优先** → 自定义读写锁
- **读者优先** → 标准读写锁

## 7. 实际应用中的组合使用

```go
// 复杂的同步场景往往需要组合多种原语
type ComplexSystem struct {
    mu       sync.Mutex          // 保护共享数据
    cond     *sync.Cond          // 条件等待
    wg       sync.WaitGroup      // 等待完成
    sem      *Semaphore          // 控制并发数
    barrier  *Barrier            // 阶段同步
}

func (cs *ComplexSystem) Process() {
    cs.wg.Add(1)
    go func() {
        defer cs.wg.Done()
        
        cs.sem.Acquire()         // 获取并发许可
        defer cs.sem.Release()
        
        cs.mu.Lock()             // 保护数据访问
        // 处理数据
        cs.mu.Unlock()
        
        cs.barrier.Wait()        // 等待所有处理完成
        
        cs.mu.Lock()
        if needMoreWork {
            cs.cond.Wait()       // 等待更多工作
        }
        cs.mu.Unlock()
    }()
    
    cs.wg.Wait()                 // 等待所有goroutine完成
}
```

## 8. 同步原语的最佳实践

### 8.1 避免死锁
- 按固定顺序获取多个锁
- 使用超时机制
- 避免嵌套锁

### 8.2 提高性能
- 减少锁的粒度
- 使用读写锁分离读写操作
- 优先使用原子操作

### 8.3 保证正确性
- 正确使用defer释放资源
- 检查条件变量的虚假唤醒
- 合理设置超时和重试机制

---

## 具体实现示例

- **锁类实现**：详见 `lock.go`
- **协调类实现**：详见 `cond.go`
